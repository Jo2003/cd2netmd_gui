This is libcdio.info, produced by makeinfo version 6.5 from
libcdio.texi.

This manual documents 'libcdio', the GNU CD Input, Output, and Control
Library.

Copyright (C) 2003-2008, 2010, 2012-2014 Rocky Bernstein and Herbert
Valerio Riedel.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included in
     the section entitled "GNU Free Documentation License".
INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* libcdio: (libcdio).           GNU Compact Disc Input, Output, and Control Library.
END-INFO-DIR-ENTRY


File: libcdio.info,  Node: Top,  Next: History,  Up: (dir)

GNU 'libcdio'
*************

This manual documents 'libcdio', the GNU CD Input, Output, and Control
Library.

Copyright (C) 2003-2008, 2010, 2012-2014 Rocky Bernstein and Herbert
Valerio Riedel.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included in
     the section entitled "GNU Free Documentation License".

* Menu:

* History::           How this came about
* Previous Work::     The problem and previous work
* Purpose::           What is in this package (and what's not)
* CD Formats::        A tour through the CD-specification spectrum
* CD Image Formats::  A tour through various CD-image formats
* CD Units::          The units that make up a CD
* How to use::        Okay enough babble, lemme at the library!
* Utility Programs::  Diagnostic programs that come with this library
* CD-ROM Access and Drivers::     CD-ROM access and drivers
* Internal Program Organization:: Looking under the hood

Appendices
* ISO-9660 Character Sets::
* Glossary::
* GNU Free Documentation License::

Indices
* General Index::       Overall index


File: libcdio.info,  Node: History,  Next: Previous Work,  Prev: Top,  Up: Top

1 History
*********

As a result of the repressive Digital Millennium Copyright Act, DMCA, I
became aware of Video CD's (VCD's).  Video CD's are not subject to the
DMCA and therefore enjoy the protection afforded by copyright but no
more.  But in order for VCD's to be competitive with DVD's, good tools -
including GPL tools - are needed for authoring and playing them.  And so
through VCD's I became aware of the excellent Video CD tools by Herbert
Valerio Riedel which form the 'vcdimager' package.

Although vcdimager is great for authoring, examining and extracting
parts of a Video CD, it is not a VCD player.  And when I looked at the
state of Video CD handling in existing VCD players: 'xine', 'MPlayer',
and 'vlc', I was a bit disappointed.  None handled playback control,
menu selections, or playing still frames and segments from track 1.

Version 0.7.12 of vcdimager was very impressive, however it lacked
exportable libraries that could be used in other projects.  So with the
blessing and encouragement of Herbert Valerio Riedel, I took to extract
and create libraries from this code base.  The result was two libraries:
one to extract information from a VCD which I called libvcdinfo, and
another to do the reading and control of a VCD. Well, actually, at this
point I should say that a Video CD is really just Video put on a
existing well-established Compact Disc or CD format.  So the library for
this is called 'libcdio' rather than 'libvcdio'.

While on the topic of the name 'libcdio', I should also explain that the
library really doesn't handle writing or output (the final "o" in the
name).  However it was felt that if I put 'libcdi' that might be
confused with a particular CD format called CD-I.

Later on, the ISO-9660 filesystem handling component from 'vcdimager'
was extracted, expanded and made a separate library.  Next the ability
to add MMC commands was added, and then CD paranoia support.  And from
there, the rest is history.


File: libcdio.info,  Node: Previous Work,  Next: Purpose,  Prev: History,  Up: Top

2 The problem and previous work
*******************************

If around the year 2002 you were to look at the code for a number of
free software CD or media players that work on several platforms such as
vlc, MPlayer, xine, or xmms to name but a few, you'd find the code to
read a CD sprinkled with conditional compilation for this or that
platform.  That is there was _no_ OS-independent programmer library for
CD reading and control even though the technology was over 10 years old;
yet there are media players which strive for OS independence.

One early CD player, 'xmcd' by Ti Kan, was I think a bit better than
most in that it tried to _encapsulate_ the kinds of CD control
mechanisms, e.g.\ SCSI, Linux ioctl, Toshiba, in a "CD Audio Device
Interface Library" called 'libdi'.  However this library is for Audio
CD's only and I don't believe this library has been used outside of
xmcd.

Another project, Simple DirectMedia Layer also encapsulates CD reading.

     SDL is a library that allows you portable low-level access to a
     video framebuffer, audio output, mouse, and keyboard.  With SDL, it
     is easy to write portable games which run on ...

Many of the media players mentioned above do in fact can make use of the
SDL library but for _video_ output only.  Because the encapsulation is
over _many_ kinds of I/O (video, joysticks, mice, as well as CD's), I
believe that the level of control provided for CD a little bit limited.
(However to be fair, it may have only been intended for games and may be
suitable for that).  Applications that just want the CD reading and
control portion I think will find quite a bit overhead.

Another related project is Jo"rg Schilling's SCSI library.  You can use
that to make a non-SCSI CD-ROM act like one that understands SCSI MMC
commands which is a neat thing to do.  However it is a little weird to
have to install drivers just so you can run a particular user-level
program.  Installing drivers often requires special privileges and
permissions and it is pervasive on a system.  It is a little sad that
along the way to creating such a SCSI library a library similar to
'libcdio' wasn't created which could be used.  Were that the case, this
library certainly never would have been written.

At the OS level there is the "A Linux CD-ROM Standard" by David van
Leeuwen from around 1999.  This defines a set of definitions and ioctl's
that mask hardware differences of various Compact Disc hardware.  It is
a great idea, however this "standard" lacked adoption on OS's other than
GNU/Linux.  Or maybe it's the case that the standard on other OS's
lacked adoption on GNU/Linux.  For example on FreeBSD there is a "Common
Access Method" (CAM) used for all SCSI access which seems not to be
adopted in GNU/Linux.(1)

Finally at the hardware level where a similar chaos exists, there has
been an attempt to do something similar with the MMC (multimedia
commands).  This attempts to provide a uniform command set for CD
devices like PostScript does for printer commands.(2)  In contrast to
PostScript where there one in theory can write a PostScript program in a
uniform ASCII representation and send that to a printer, for MMC
although there are common internal structures defined, there is no
common syntax for representing the structures or an OS-independent
library or API for issuing MMC-commands which a programmer would need to
use.  Instead each Operating System has its own interface.  For example
Adaptec's ASPI or Microsoft's DeviceIoControl on Microsoft Windows, or
IOKit for Apple's OS/X, or FreeBSD's CAM. I've been positively awed at
how many different variations and differing levels of complexity there
are for doing basically the same thing.  How easy it is to issue an MMC
command from a program varies from easy to very difficult.  And
mastering the boilerplate code to issue an MMC command on one OS really
doesn't help much in figuring out how to do it on another OS. So in
'libcdio' we provide a common (and hopefully simple) API to issue MMC
commands.

   ---------- Footnotes ----------

   (1) And I'm thankful for that since, at least for MMC commands, it is
inordinately complicated and in some places arcane.

   (2) I wrote "attempts" because over time the command set has changed
and now there are several different commands to do a particular function
like read a CD table of contents and some hardware understands some of
the version of the commands set but might not others


File: libcdio.info,  Node: Purpose,  Next: CD Formats,  Prev: Previous Work,  Up: Top

3 What is in this package (and what's not)
******************************************

The library, 'libcdio', encapsulates CD-ROM reading and control.
Applications wishing to be oblivious of the OS- and device-dependent
properties of a CD-ROM can use this library.

Also included is a library, 'libiso9660', for working with ISO-9660
filesystems.

Some support for disk-image types like cdrdao's TOC, CDRWIN's BIN/CUE
and Ahead Nero's NRG format is available, so applications that use this
library also have the ability to read disc images as though they were
CDs.

'libcdio' also provides a way to issue SCSI "MultiMedia Commands", MMC.
MMC is supported by many hardware CD-ROM manufacturers; and in some
cases where a CD-ROM doesn't understand MMC directly, some Operating
Systems (such as GNU/Linux, Solaris, or FreeBSD or Microsoft Windows
ASPI to name a few) provide the MMC emulation.(1)

As a separate package under a separate GPL2 license are
'libcdio_paranoia', and 'libcdio_cdda' libraries for applications which
want to use cdparanoia's error-correction and jitter detection.

The first use of the library in this package are the Video CD authoring
and ripping tools, VCDImager (<http://vcdimager.org>).  See
<http://www.gnu.org/software/libcdio/projects.html> for a list of
projects using 'libcdio'.

A version of the CD-DA extraction tool cdparanoia,
<http://www.xiph.org/paranoia>, and its library which corrects for
CD-ROM jitter are part of the distribution.

Also included in the libcdio package is a utility program 'cd-info'
which displays CD information: number of tracks, CD-format and if
possible basic information about the format.  If libcddb
(<http://libcddb.sourceforge.net>) is available, the 'cd-info' program
will display CDDB matches on CD-DA discs.  And if a new enough version
of libvcdinfo is available from the vcdimager project, then 'cd-info'
shows basic VCD information.

Other utility programs in the libcdio package are:

'cdda-player'

     shows off 'libcdio' audio and CD-ROM control commands.  It can play
     a track, eject or load media and show the the status of a CD-DA
     that is might be currently played via the audio control commands.
     It can be run in batch mode or has a simple curses-based interface.

     If libcddb is available or a CD has CD-Text and your CD-ROM drive
     supports CD-Text, track/album information about the CD can be
     shown.

'cd-drive'

     shows what drivers are available and some basic properties of
     cd-drives attached to the system.  Media may have to be inserted in
     order to get this info.  The program also lists out drive
     capabilities

'cd-read'
     performs low-level block reading of a CD or CD image

'iso-info'

     displays ISO-9660 information from an ISO-9660 image.  Below is
     some sample output

          iso-info version 0.82 x86_64-unknown-linux-gnu
          Copyright (c) 2003, 2004, 2005, 2007, 2008 R. Bernstein
          This is free software; see the source for copying conditions.
          There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
          PARTICULAR PURPOSE.
          __________________________________
          ISO 9660 image: ../test/joliet.iso
          Application: K3B THE CD KREATOR VERSION 0.11.12 (C) 2003 SEBASTIAN TRUEG AND...
          Preparer   : K3b - Version 0.11.12
          Publisher  : Rocky Bernstein
          System     : LINUX
          Volume     : K3b data project
          Volume Set :
          __________________________________
          ISO-9660 Information
          /:
           Oct 22 2004 19:44  .
           Oct 22 2004 19:44  ..
           Oct 22 2004 19:44  libcdio

          /libcdio/:
           Oct 22 2004 19:44  .
           Oct 22 2004 19:44  ..
           Mar 12 2004 02:18  COPYING
           Jun 26 2004 07:01  README
           Aug 12 2004 06:22  README.libcdio
           Oct 22 2004 19:44  test

          /libcdio/test/:
           Oct 22 2004 19:44  .
           Oct 22 2004 19:44  ..
           Jul 25 2004 06:52  isofs-m1.cue

'iso-read'

     extracts files from an ISO-9660 image.

'mmc-tool'

     a program for issuing some MMC commands

Historically, 'libcdio' did not support write access to drives.  In
conjunction with additional work in a separate project 'libburn', Thomas
Schmitt has modified 'libcdio' to enable sending SCSI write commands on
some of the drivers.  This enables other programs like 'libburn' to
write to CD's, DVD's and Blu-Ray discs.

For the OS drivers which are lacking write access, volunteers are
welcome.

   ---------- Footnotes ----------

   (1) This concept of software emulation of a common hardware command
language is common for printers such as using ghostscript to private
postscript emulation for a non-postscript printer.


File: libcdio.info,  Node: CD Formats,  Next: CD Image Formats,  Prev: Purpose,  Up: Top

4 CD Formats
************

Much of what I write in this section can be found elsewhere.  See for
example <http://www.pctechguide.com/08cd-rom.htm> or
<http://www.pcguide.com/ref/cd/format.htm>

We give just enough background here to cover Compact Discs and Compact
Disc formats that are handled by this library.

The Sony and Philips Corporations invented and Compact Disc (CD) in the
early 1980s.  The specifications for the layout is often referred to by
the color of the cover on the specification.

* Menu:

* Red Book::        Red Book (CD-DA) CD Text, CDDB
* Yellow Book::     Yellow Book (CD-ROM Digital Data)
* Green Book::      Green Book (CD-i)
* White Book::      White Book (DV, Video CD)


File: libcdio.info,  Node: Red Book,  Next: Yellow Book,  Up: CD Formats

4.1 Red Book (CD-DA)
====================

* Menu:

* CD Text::         CD Text and CD+G
* CDDB::            Internet CD Database (CDDB)

The first type of CD that was produced was the Compact Disc Digital
Audio (CD-DA) or just plain "audio CD". The specification, ICE 60908
(formerly IEC 908) is commonly called the "Red Book",
'<http://en.wikipedia.org/wiki/Red_Book_(audio_CD_standard)>'.  Music
CD's are recorded in this format which basically allows for around 74
minutes of audio per disc and for that information to be split up into
tracks.  Tracks are broken up into "sectors" and each sector contains up
to 2,352 bytes.  To play one 44.1 kHz CD-DA sampled audio second, 75
sectors are used.

The minute/second/frame numbering of sectors or MSF format is based on
the fact that 75 sectors are used in a second of playing of sound.  (And
for almost every other CD format and application the MSF format doesn't
make that much sense).

In 'libcdio' when you you want to read an audio sector, you call
'cdio_read_audio_sector()' or 'cdio_read_audio_sectors()'.

In addition the the audio data "channel" a provision for other
information or _subchannel_ information) can be stored in a sector.
Other subchannels include a Media Catalog Number (also abbreviated as
MCN and sometimes a UPC), or album meta data (also called CD-Text).
Karioke graphics can also be stored in a format called _CD+G_.


File: libcdio.info,  Node: CD Text,  Next: CDDB,  Up: Red Book

4.1.1 CD Text, CD+G
-------------------

CD Text is an extension to the CD-DA standard that adds the ability to
album and track meta data (titles, artist/performer names, song titles)
and graphical (e.g.  Karaoke) information.  For an alternative way to
get album and track meta-data see *Note CDDB::.

Information is stored in such a way that it doesn't interfere with the
normal operation of any CD players or CDROM drives.  There are two
different parts of the CD where the data can be stored.

The first place the information can be recorded is in the R-W sub codes
in the lead in area of the CD. This information is stored as a single
block of data and is the format.  The method for reading this data from
a CDROM drive is covered under the Sony proposal to the MMC
specification.  The format of the data is partially covered in the MMC
specification.

CD Text information is stored in this area.  The format that follows the
Interactive Text Transmission System (ITTS) is the same data
transmission standard used by such things as Digital Audio Broadcasting
(DAB), and virtually the same as the data standard for the MiniDisc.

The second place the information can be recorded is in the R-W sub codes
in the program area of the CD giving a data capacity of roughly 31MB.
CD+G (CD w/graphics) uses this method.

The methods for reading this data from a CD-ROM drive were first covered
by the programming specs from the individual drive manufacturers.  In
the case of ATAPI drives, the SFF8020 spec covers the reading of the RW
subcodes.  Subsequently it has been encorporated into the MMC
specifications.

Not all drives support reading the RW subcodes from the program area.
However for those that do, 'libcdio' provides a way to get at this
information via 'cdtext_get()' and its friends.

There is a separate document in this distribution describing CD-Text
information and how it is encoded.


File: libcdio.info,  Node: CDDB,  Prev: CD Text,  Up: Red Book

4.1.2 Internet CD Database (CDDB)
---------------------------------

CDDB is an database on the Internet of of CD album/track, artist, and
genre information similar to CD Text information.  Using track
information (number of tracks and length of the tracks), devices that
have access to the Internet can query for meta information and
contribute information for CD's where there is no existing information.
When storage is available (such as you'd expect for any program using
'libcdio', the information is often saved for later use when the
Internet is not available; people tend request the same information
since they via programs play the same music.

Obtaining CD meta information when none is encoded in an audio CD is
useful in media players or making ones own compilations from audio CDs.

There are currently two popular CDDB services on the Internet.  The
original database has been renamed Gracenote and is a profit making
entity.  FreeDB (<http://freedb.org> is an open source CD information
resource that is free for developers and the public to use.

As there already is an excellent library for handling CDDB libcddb
(<http://libcddb.sourceforge.net> we suggest using that.  Our utility
program 'cd-info' will make use it if it is available and it's what we
use in our applications that need it.


File: libcdio.info,  Node: Yellow Book,  Next: Green Book,  Prev: Red Book,  Up: CD Formats

4.2 Yellow Book (CD-ROM Digital Data)
=====================================

The CD-ROM specification or the "Yellow Book" followed a few years later
(Standards ISO/IEC 10149), and describes the extension of CD's to store
computer data, i.e.  CD-ROM (Compact Disk Read Only Memory).

The specification in the Yellow Book defines two modes: Mode 1 and Mode
2.

* Menu:

* ISO 9660::
* Mode 1::           Mode 1 Format
* Mode 2::           Mode 2 Format


File: libcdio.info,  Node: ISO 9660,  Next: Mode 1,  Up: Yellow Book

4.2.1 ISO 9660
--------------

* Menu:

* ISO 9660 Level 1::
* ISO 9660 Level 2::
* ISO 9660 Level 3::
* Joliet Extensions::
* Rock Ridge Extensions::

The Yellow Book doesn't specify how data is to be stored on a CD-ROM. It
was feared that different companies would implement proprietary data
storage formats using this specification, resulting in incompatible data
CDs.  To prevent this, representatives of major manufacturers met at the
High Sierra Hotel and Casino in Lake Tahoe, NV, in 1985, to define a
standard for storing data on CDs.  This format was nicknamed High Sierra
Format.  In a slightly modified form it was later adopted as ISO the ISO
9660 standard.  This standard is further broken down into 3 "levels",
the higher the level, the more permissive.


File: libcdio.info,  Node: ISO 9660 Level 1,  Next: ISO 9660 Level 2,  Up: ISO 9660

4.2.1.1 ISO 9660 Level 1
........................

Level 1 ISO 9660 defines names in the 8+3 convention so familiar to
MS-DOS: eight characters for the filename, a period, and then three
characters for the file type, all in upper case.  The allowed characters
are A-Z, 0-9, ".", and "_".Level 1 ISO 9660 requires that files occupy a
contiguous range of sectors.  This allows a file to be specified with a
start block and a count.  The maximum directory depth is 8.  For a table
of the characters, see *Note ISO-9660 Character Sets::.


File: libcdio.info,  Node: ISO 9660 Level 2,  Next: ISO 9660 Level 3,  Prev: ISO 9660 Level 1,  Up: ISO 9660

4.2.1.2 ISO 9660 Level 2
........................

Level 2 ISO 9660 allows far more flexibility in filenames, but isn't
usable on some systems, notably MS-DOS.


File: libcdio.info,  Node: ISO 9660 Level 3,  Next: Joliet Extensions,  Prev: ISO 9660 Level 2,  Up: ISO 9660

4.2.1.3 ISO 9660 Level 3
........................

Level 3 ISO-9660 allows non-contiguous files, useful if the file was
written in multiple packets with packet-writing software.

There have been a number of extensions to the ISO 9660 CD-ROM file
format.  One extension is Microsoft's Joliet specification, designed to
resolve a number of deficiencies in the original ISO 9660 Level 1 file
system, and in particular to support the long file names used in Windows
95 and subsequent versions of Windows.

Another extension is the Rock Ridge Interchange Protocol (RRIP), which
enables the recording of sufficient information to support POSIX File
System semantics.


File: libcdio.info,  Node: Joliet Extensions,  Next: Rock Ridge Extensions,  Prev: ISO 9660 Level 3,  Up: ISO 9660

4.2.1.4 Joliet Extensions
.........................

Joliet extensions were an upward-compatible extension to the ISO 9660
specification that removes the limitation initially put in to deal with
the limited filename conventions found in Microsoft DOS OS. In
particular, the Joliet specification allows for long filenames and
allows for UCS-BE (BigEndian Unicode) encoding of filenames which
include mixed case letter, accented characters spaces and various
symbols.

The way all of this is encoded is by adding a second directory and
filesystem structure in addition to or in parallels to original ISO 9600
filesystem.  The root node of the ISO 9660 filesystem is found via the
_Primary Volume Descriptor_ or _PVD_. The root of the Joliet-encode
filesystem is found in a Supplementary Volume Descriptor or _SVD_
defined in the ISO 9660 specification.  The SVD structure is almost
identical to a PVD with a couple of unused fields getting used and with
the filename encoding changed to UCS-BE.


File: libcdio.info,  Node: Rock Ridge Extensions,  Prev: Joliet Extensions,  Up: ISO 9660

4.2.1.5 Rock Ridge Extensions
.............................

Using the Joliet Extension one overcome the limitedness of the original
ISO-9660 naming scheme.  But another and probably better method is to
use the Rock Ridge Extension.  Not only can one store a filename as one
does in a POSIX OS, but the other file attributes, such as the various
timestamps (creation, modification, access), file attributes (user,
group, file mode permissions, device type, symbolic links) can be
stored.  This is much as one would do in XA attributes; however the two
are not completely interchangeable in the information they store: XA
does _not_ address filename limitations, and the Rock Ridge extensions
don't indicate if a sector is in Mode 1 or Mode 2 format.

The Rock Ridge extension makes use of a hook that was defined as part of
the ISO 9660 standard.


File: libcdio.info,  Node: Mode 1,  Next: Mode 2,  Prev: ISO 9660,  Up: Yellow Book

4.2.2 Mode 1 (2048 data bytes per sector)
-----------------------------------------

Mode 1 is the data storage mode used by to store computer data.  There
are 3 layers of error correction.  A Compact Disc using only this format
can hold at most 650 MB. The data is laid out in basically the same way
as in and audio CD format, except that the 2,352 bytes of data in each
block are broken down further.  2,048 of these bytes are for "real"
data.  The other 304 bytes are used for an additional level of error
detecting and correcting code.  This is necessary because data CDs
cannot tolerate the loss of a handful of bits now and then, the way
audio CDs can.

In 'libcdio' when you you want to read a mode1 sector you call the
'cdio_read_mode1_sector()' or 'cdio_read_mode1_sectors()'.


File: libcdio.info,  Node: Mode 2,  Prev: Mode 1,  Up: Yellow Book

4.2.3 Mode 2 (2336 data bytes per sector)
-----------------------------------------

Mode 2 data CDs are the same as mode 1 CDs except that the error
detecting and correcting codes are omitted.  So still there are 2 layers
of error correction.  A Compact Disc using only this mode can thus hold
at most 742 MB. Similar to audio CDs, the mode 2 format provides a more
flexible vehicle for storing types of data that do not require high data
integrity: for example, graphics and video can use this format.  But in
contrast to the Red Book standard, different modes can be mixed
together; this is the basis for the extensions to the original data CD
standards known as CD-ROM Extended Architecture, or CD-ROM XA. CD-ROM XA
formats currently in use are CD-I Bridge formats, Photo CD and Video CD
plus Sony's Playstation.

In 'libcdio' when you you want to read a mode1 sector you call the
'cdio_read_mode2_sector()' or 'cdio_read_mode2_sectors()'.


File: libcdio.info,  Node: Green Book,  Next: White Book,  Prev: Yellow Book,  Up: CD Formats

4.3 Green Book (CD-i)
=====================

This was a CD-ROM format developed by Philips for CD-i (an obsolete
embedded CD-ROM application allowing limited user user interaction with
films, games and educational applications).  The format is ISO 9660
compliant and introduced mode 2 form 2 addressing.  It also contains XA
(Extended Architecture) attributes.

Although some Green Book discs contain CD-i applications which can only
be played on a CD-i player, others have films or music videos.  Video
CDs in Green-Book format are labeled "Digital Video on CD." The Green
Book for video is largely superseded by White book CD-ROM which draws on
this specification.


File: libcdio.info,  Node: White Book,  Prev: Green Book,  Up: CD Formats

4.4 White Book (DV, Video CD)
=============================

The White Book was released by Sony, Philips, Matsushita, and JVC in
1993, defines the Video CD specification.  The White Book is also known
as Digital Video (DV).

A Video CD contains one data track recorded in CD-ROM XA Mode 2 Form 2.
It is always the first track on the disc (Track 1).  The ISO-9660 file
structure and a CD-i application program are recorded in this track, as
well as the Video CD Information Area which gives general information
about the Video Compact Disc.  After the data track, video is written in
one or more subsequent tracks within the same session.  These tracks are
also recorded in Mode 2 Form 2.

In 'libcdio' when you you want to read a mode2 format 2 audio sector you
call the 'cdio_read_mode2_sector()' or 'cdio_read_mode2_sectors()'
setting 'b_form2' to 'true'.


File: libcdio.info,  Node: CD Image Formats,  Next: CD Units,  Prev: CD Formats,  Up: Top

5 CD Image Formats
******************

* Menu:

* CDRDAO TOC Format::
* CDRWIN BIN/CUE Format::
* NRG Format::

In both the 'cdrdao' and bin/cue formats there is one meta-file with
extensions '.toc' or '.cue' respectively and one or more files (often
with the extension '.bin') which contains the content of tracks.  The
format of the track data is often interchangeable between the two
formats.  For example, in 'libcdio''s regression tests we make use of
this to reduce the size of the test data and just provide alternate
meta-data files ('.toc' or '.cue').

In contrast to the first two formats, the NRG format consists of a
single file.  This has the advantage of being a self-contained unit: in
the other two formats it is possible for the meta file to refer to a
file that can't be found.  A disadvantage of the NRG format is that the
meta data can't be easily viewed or modified say in a text file as it
can be with the first two formats.  In conjunction with this
disadvantage is another disadvantage that the format is not documented,
so how 'libcdio' interprets an NRG image is based on inference.  It is
recommended that one of the other forms be used instead of NRG where
possible.


File: libcdio.info,  Node: CDRDAO TOC Format,  Next: CDRWIN BIN/CUE Format,  Up: CD Image Formats

5.1 CDRDAO TOC Format
=====================

This is 'cdrdao''s CD-image description format.  Since this program is
GPL and everything about it is in the open, it is the preferred format
to use.  (Alas, at present it isn't as well supported in 'libcdio' as
the BIN/CUE format.)

The _toc_-file describes what data is written to the media in the
CD-ROM; it allows control over track/index positions, pre-gaps and
sub-channel information.  It is a text file, so a text editor can be
used to create, view or modify it.

The 'cdrdao(1) manual page', contains more information about this
format.

5.1.1 CDRDAO Grammar
--------------------

Below are the lexical tokens and grammar for a cdrdao TOC. It was taken
from the cdrdao's pacct grammar; the token and nonterminal names are the
same.

     #lexclass START
     #token Eof		"@"
     #token                  "[\t\r\ ]+"
     #token Comment          "//~[\n@]*"
     #token                  "\n"
     #token BeginString      "\""
     #token Integer          "[0-9]+"
     #tokclass AudioFile     { "AUDIOFILE" "FILE" }

     #lexclass STRING
     #token EndString        "\""
     #token StringQuote      "\\\""
     #token StringOctal      "\\[0-9][0-9][0-9]"
     #token String           "\\"
     #token String           "[ ]+"
     #token String           "~[\\\n\"\t ]*"


     <toc>  ::= ( "CATALOG" <string> | <tocType> )* { <cdTextGlobal> }
                ( <track> )+ Eof

     <track> ::= "TRACK" <trackMode>
         { <subChannelMode> }
         (  "ISRC" <string> | { "NO" } "COPY" | { "NO" } "PRE_EMPHASIS"
         | "TWO_CHANNEL_AUDIO"  | "FOUR_CHANNEL_AUDIO" )*
         { <cdTextTrack>  }
         { "PREGAP" <msf> }
         ( <subTrack> | "START" { msf } | "END" { msf } )+
         ( "INDEX" <msf> )*

     <subTrack> ::=
          AudioFile <string> { "SWAP"  } { "#" <sLong>  }  <samples>
          | "DATAFILE" <string> { "#" <sLong> { <dataLength> } }
          | "FIFO" <string> <dataLength>
          | "SILENCE" <samples>
          | "ZERO" { dataMode  } { <subChannelMode>  } <dataLength>


     <string> ::=  BeginString ( String | StringQuote | StringOctal )+
                 EndString

     <stringEmpty> ::= BeginString ( String | StringQuote | StringOctal )*
                     EndString

     <uLong> ::= Integer

     <sLong> ::= Integer

     <msf> ::= Integer ":" Integer ":" Integer

     <samples> ::= <msf> | <uLong>

     <dataLength> ::= <msf> | <uLong>

     <dataMode> ::=  "AUDIO" | "MODE0" | "MODE1" | "MODE1_RAW" | "MODE2"
          | "MODE2_RAW" | "MODE2_FORM1" | "MODE2_FORM2" | "MODE2_FORM_MIX"

     <trackMode> ::= "AUDIO" | "MODE1" | "MODE1_RAW" | "MODE2"
          | "MODE2_RAW"  | "MODE2_FORM1" | "MODE2_FORM2" | "MODE2_FORM_MIX"

     <subChannelMode> ::= "RW" | "RW_RAW"

     <tocType> ::= "CD_DA" | "CD_ROM" | "CD_ROM_XA" | "CD_I"

     <packType> ::= "TITLE" | "PERFORMER" | "SONGWRITER" | "COMPOSER" | "ARRANGER"
          | "MESSAGE" | "DISC_ID" | "GENRE" | "TOC_INFO1" | "TOC_INFO2"
          | "RESERVED1" | "RESERVED2" | "RESERVED3" | "RESERVED4" | "UPC_EAN" |
          "ISRC" | "SIZE_INFO"

     <binaryData> ::=  "{"
         { Integer ( "," Integer  )* }
         "}"

     <cdTextItem> ::= <packType>  ( <stringEmpty> | <binaryData> )

     <cdTextBlock> ::=  "LANGUAGE" Integer "{" ( <cdTextItem> )* "}"

     <cdTextLanguageMap> ::=
         "LANGUAGE_MAP" "{"
         ( Integer  ":" (  Integer | "EN"  ) )+
         "}"

     <cdTextTrack> ::=  "CD_TEXT" "{" ( <cdTextBlock> )*  "}"

     <cdTextGlobal> ::= "CD_TEXT" "{" { <cdTextLanguageMap> } ( <cdTextBlock> )* "}"


File: libcdio.info,  Node: CDRWIN BIN/CUE Format,  Next: NRG Format,  Prev: CDRDAO TOC Format,  Up: CD Image Formats

5.2 CDRWIN BIN/CUE Format
=========================

The format referred to as _CDRWIN BIN/CUE Format_ in this manual is a
popular CD image format used in the PC world.  Not unlike 'cdrdao''s TOC
file, the _cue_ file describes the track layout, i.e.  how the sectors
are to be placed on the CD media.  The _cue_ file usually contains a
reference to a file traditionally having the '.bin' extension in its
filename, the _bin_ file.  This _bin_ file contains the sector data
payload which is to be written to the CD medium according to the
description in the _cue_ file.

The following is an attempt to describe the subset of the '.cue' file
syntax used in 'libcdio' and vcdimager in an EBNF-like notation:

5.2.1 BIN/CUE Grammar
---------------------

     <cue-document> ::= +( <file-line> +<track-expr> )

     <digit> ::= "0" | "1" ... "8" | "9"
     <number> ::= +<digit>
     <msf> ::= <digit><digit> ":" <digit><digit> ":" <digit><digit>

     <file-line> ::= "FILE" <pathname-expr> <file-type> <EOL>

     <pathname-expr> ::= [ "\"" ] <pathname-str-without-spaces> [ "\"" ]
                       | "\"" <pathname-str> "\""

     <file-type> ::= "BINARY"

     <track-expr> ::= <track-line> [ <flag-line> ]
                      [ <pregap-line> ] *<index-line> [ <postgap-line> ]

     <flag-line> ::= "FLAGS" *<flag-type> <EOL>
     <flag-type> ::= "DCP"

     <track-line> ::= "TRACK" <number> <track-type> <EOL>

     <pregap-line> ::= "PREGAP" <msf> <EOL>

     <index-line> ::= "INDEX" <number> <msf> <EOL>

     <postgap-line> ::= "POSTGAP" <msf> <EOL>

     <track-type> ::= "AUDIO" | "MODE1/2048" | "MODE1/2352"
                    | "MODE2/2336" | "MODE2/2352"

     <comment-line> ::= "REM" *<char> <EOL>


File: libcdio.info,  Node: NRG Format,  Prev: CDRWIN BIN/CUE Format,  Up: CD Image Formats

5.3 NRG Format
==============

The format referred to as _NRG Format_ in this manual is another popular
CD image format.  It is available only on Nero software on a Microsoft
Windows Operating System.  It is proprietary and not generally
published, so the information we have comes from guessing based on
sample CD images.  So support for this is incomplete and using this
format is not recommended.

Unlike 'cdrdao''s TOC file the BIN/CUE format everything is contained in
one file that one can edit.  Meta information such as the number of
tracks and track format is contained at the end of the file.  This
information is not intended to be edited through a text editor.


File: libcdio.info,  Node: CD Units,  Next: How to use,  Prev: CD Image Formats,  Up: Top

6 The units that make up a CD
*****************************

* Menu:

* Tracks::   Tracks
* Sectors::  Block addressing (MSF, LSN, LBA)
* Pre-gaps::  Track pre-gaps


File: libcdio.info,  Node: Tracks,  Next: Sectors,  Up: CD Units

6.1 tracks -- disc subdivisions
===============================

In this section we describe CD properties and terms that we make use of
in 'libcdio'.

A CD is formatted into a number of _tracks_, and a CD can hold at most
99 such tracks.  This is defined by 'CDIO_CD_MAX_TRACKS' in
'cdio/sector.h'.  Between some tracks CD specifications require a "2
second" in gap (called a _lead-in gap_.  This is unused space with no
"data" similar to the space between tracks on an old phonograph.  The
word "second" here really refers to a measure of space and not really
necessarily an amount of time.  However in the special case that the CD
encodes an audio CD or CD-DA, the amount of time to play a gap of this
size will take 2 seconds.

The beginning (or inner edge) of the CD is supposed to have a "2 second"
lead-in gap and there is supposed to be another "2 second" _lead-out_
gap at the end (or outer edge) of the CD.

People have discovered that they can put useful data in the _lead-in_
and _lead-out_ gaps, and their equipment can read this, violating the
standards but allowing a CD to store more data.

In order to determine the number of tracks on a CD and where they start,
commands are used to get this table-of-contents or _TOC_ information.
Asking about the start of the _lead-out track_ gives the amount of data
stored on the Compact Disk.  To make it easy to specify this leadout
track, special constant 0xAA (decimal 170) is used to indicate it.  This
is safe since this is higher than the largest legal track position.  In
'libcdio', 'CDIO_CDROM_LEADOUT_TRACK' is defined to be this special
value.


File: libcdio.info,  Node: Sectors,  Next: Pre-gaps,  Prev: Tracks,  Up: CD Units

6.2 block addressing (MSF, LSN, LBA)
====================================

A track is broken up into a number of 2352-byte _blocks_ which we
sometimes call _sectors_ or _frames_.  Whereas tracks may have a gap
between them, a block or sector does not.  (In 'libcdio' the block size
constant is defined using 'CDIO_CD_FRAMESIZE_RAW').

A Compact Disc has a limit on the number of blocks or sectors.  This
values is defined by constant 'CDIO_CD_MAX_LSN' in 'cdio/sector.h'.

One can addressing a block in one of three formats.  The oldest format
is by it's minute/second/frame number, also referred to as _MSF_ and
written in time-like format MM:SS:FF (e.g.  30:01:40).  It is best
suited in audio (Red Book) applications.  In 'libcdio', the type 'msf_t'
can be used to declare variables to hold such values.  Minute, second
and frame values are one byte _and stored BCD notation_.(1)  There are
'libcdio' conversion routines 'cdio_from_bcd8()' and 'cdio_to_bcd8()' to
convert the minute, second, and frame values into or out of integers.
If you want to print a field in a BCD-encoded MSF, one can use the
format specifier '%x' _(not '%d')_ and things will come out right.

In the MSF notation, there are 75 "frames" in a "second," and the
familiar (if awkward) 60 seconds in a minute.  _Frame_ here is what we
called a _block_ above.  The CD specification defines "frame" to be
_another_ unit which makes up a block.  Very confusing.  A frame is also
sometimes called a sector, analogous to hard-disk terminology.

Even more confusing is using this time-like notation for an address or
for a length.  Too often people confuse the MSF notation this with an
amount of time.  A "second" (or 'CDIO_CD_FRAMES_PER_SEC' blocks) in this
notation is only a second of playing time for something encoded as
CD-DA. It does _not_ necessarily represent the amount time that it will
take to play a of Video CD--usually you need more blocks than this.  Nor
does it represent the amount of data used to play a second of an
MP3--usually you need fewer blocks than this.  It is also not the amount
of time your CD-ROM will take to read a "second" of data off a Compact
Disc: for example a 12x CD player will read 12x 'CDIO_CD_FRAMES_PER_SEC'
'CDIO_CD_FRAMSIZE_RAW'-byte blocks in a one second of time.

When programming, unless one is working with a CD-DA (and even here,
only in a time-like fashion), is generally more cumbersome to use an MSF
rather than a LBA or LSN described below, since subtraction of two MSF's
has the awkwardness akin to subtraction using Roman Numerals.

A simpler way to address a block is to use a "Logical Sector Number"
(_LSN_) or a "Logical Block Address (_LBA_). In the MMC-5 glossary these
are synonymous terms.  However historically it has been used
differently.  In libcdio, to convert a LBA into an LSN you just subtract
150.  Both LBA's and LSN's can be negative.

   ---------- Footnotes ----------

   (1) Perhaps this is a 'libcdio' design flaw.  It was originally done
I guess because it was convenient for VCDs.


File: libcdio.info,  Node: Pre-gaps,  Prev: Sectors,  Up: CD Units

6.3 track pre-gaps - CD-DA discs and gaps
=========================================

Gaps are possibly one of the least understood topics in audio discs.  In
the case of CD-DA discs, standards require a silent 2 second gap before
the first audio track and after the last audio track (in each session.)
These are respectively referred to as _lead-in_ and _lead-out_ gaps.  No
other gaps are required.  It is important not to confuse the required
_lead-in_ and _lead-out_ gaps with the optional track _pre-gap_s.  Track
_pre-gap_s are the gaps that may occur between audio tracks.  Typically,
track _pre-gap_s are filled with silence so that the listener knows that
one song has ended, and the next will soon begin.  However, track
_pre-gap_s do not have to contain silence.  One exception is an audio
disc of a live performance.  Because the performer may seamlessly move
from one piece of the performance to the next, it would be unnatural for
the disc to contain silence between the two pieces.  Instead, the track
number updates with no interruption in the performance.  This allows the
listener to either hear the entire performance without unnatural
interruptions, or to conveniently skip to certain pieces of the
performance.  Finally, some CD-DA discs-whose behavior will be described
below-lack track _pre-gap_s altogether although they must still include
the _lead-in_ and _lead-out_ gaps.

In order to understand the track _pre-gap_s that occur between audio
tracks, it is necessary to understand how CD players display the track
number and time.  Embedded in each block of audio data is non-audio
information known as the _Q sub-channel_.  The _Q sub-channel_ data
tells the CD player what track number and time it should display while
it is playing the block of audio data in which the _Q sub-channel_ data
is embedded.  Near the end of some tracks, the _Q sub-channel_ may
instruct the CD player to update the track number to the next track, and
display a count down to the next track, often starting at -2 seconds and
proceeding to zero.  This is known as an audio track _pre-gap_.  It may
either contain silence, or as previously discussed-in the case of live
performances-it may contain audio.  Almost as often as not, there is no
_pre-gap_ whatsoever.  Regardless, an audio track _pre-gap_ is purely
determined by the contents of the _Q sub-channel_, which is embedded in
each audio sector.  This has some interesting implications for the track
forward button.

When the track forward button is pressed on a CD player, the CD player
advances to the next track, skipping that track's _pre-gap_.  This is
because the CD player uses the starting address of the track from the
disc's table of contents (TOC) to determine where to start playing a
track when either the track forward or track backward buttons are
pressed.  So to hear a _pre-gap_ for track 4, the listener must either
listen to track 3 first, or use the track forward or backward buttons to
go to track 4, then use the seek backward button to back up into track
4's _pre-gap_, which is really part of track 3, at least according to
the TOC. Track 1 _pre-gap_s are especially interesting because some
commercial discs have audio hidden before the beginning of the first
track!  The only way to hear this hidden audio with a standard player is
to use the seek backward button as soon as track 1 begins playing!

Audio track _pre-gap_s may be specified in a couple of different ways in
the popular cue file format.  The first way of specifying a _pre-gap_ is
to use the 'PREGAP' command.  This will place a _pre-gap_ containing
silence before a track.  The second way of specifying a _pre-gap_ is to
give a track an 'INDEX 00' as well as the more normal 'INDEX 01'.
'INDEX 01' will be used to specify the start of the track in the disc's
TOC, while 'INDEX 00' will be used to specify the start of the track's
_pre-gap_ as recorded in the _Q sub-channel_.  'INDEX 00' is ordinarily
used for specifying track _pre-gap_s that contain audio rather than
silence.  Thus, the cue file format may be used to specify track
_pre-gap_s with silence or audio, depending on whether the 'PREGAP' or
'INDEX 00' commands are specified.  If neither type of _pre-gap_ is
specified for a track, no _pre-gap_ is created for that track, which
merely means the absence of _pre-gap_ information in the _Q
sub-channel_, and the lack of a short count down to the next track.

Various CD-DA ripping programs take various approaches to track
_pre-gap_s.  Some ripping programs ignore track _pre-gap_s altogether,
relying solely on the disc's TOC to determine where tracks begin and
end.  If a disc is ripped with such a program, then re-burned later, the
resulting disc will lack track _pre-gap_s, and thereby lack the playback
behavior of counting down to the next track.  Other ripping programs
detect track _pre-gap_s and record them in the popular cue file format
among others.  Such ripping programs sometimes allow the user to
determine whether track _pre-gap_s will be appended to the prior track
or pre-pended to the track to which they "belong".  Note that if a
ripping program is ignorant of track _pre-gap_s, the track _pre-gap_s
will be appended to the prior track, because that is where the disc's
TOC puts them.  Thus, there are many different ways an application may
chose to deal with track _pre-gap_s.  Consequently, 'libcdio' does not
dictate the policy a ripping program should use in dealing with track
_pre-gap_s.  Hence, 'libcdio' provides the
'cdio_get_track_pregap_[lba|lsn]()' interfaces to allow the application
to deal with track _pre-gap_s as it sees fit.

Note that the 'cdio_get_track_pregap_[lba|lsn]()' interfaces currently
only provide information for CDRDAO TOC, CDRWIN BIN/CUE, and NRG images.
Getting the track _pre-gap_s from a CD drive is a more complicated
problem because not all CD drives support reading the _Q sub-channel_
_directly_ at _high_ speed, and there is no interface to determine
whether or not a drive supports this optional feature, aside from trying
to read the _Q sub-channel_, and possibly incurring IO errors.  However,
all drives _do_ support reading the _Q sub-channel_ _indirectly_ while
playing an audio disc by asking the drive for the current position.
Unfortunately, this occurs at normal playback speed, and requires a
certain settling time after the disc starts playing.  Thus, using this
_slow_ interface requires a more sophisticated algorithm, such as binary
search or some heuristic, like backing up progressively from the end of
the prior track to look for the next track's _pre-gap_.  Note that CD
drives seek _slow_ly, so it is better to simply use a drive that can
read the _Q sub-channel_ directly at _high_ speed, and avoid complicated
software solutions.  (Not to mention that if the user has an older
system with an analog audio cable hooked up between their soundboard and
their drive, and a ripping program uses the _slow_ interface, the user
will hear bits of the audio on the disc!)  Consequently, because there
is no good universal solution to the problem of reading the _Q
sub-channel_ from a drive, 'libcdio' currently leaves this problem up to
the application, a problem which is readily approachable through either
'libcdio''s MMC interface or 'libcdio''s cdda interface.  For an example
of one such application, see <https://gna.org/projects/cued/>.

The preceding section on track _pre-gaps_ and CD-DA was contributed by
Robert William Fuller (<hydrologiccycle@gmail.com>).


File: libcdio.info,  Node: How to use,  Next: Utility Programs,  Prev: CD Units,  Up: Top

7 How to use
************

The 'libcdio' package comes with a number of small example programs in
the directory 'example' which demonstrate different aspects of the
library and show how to use the library.  The source code to all of the
examples here are contained on the package.

Other sources for examples would be the larger utility programs
'cd-drive', 'cd-info', 'cd-read', 'iso-info', and 'iso-read' which are
all in the 'src' directory of the 'libcdio' package.  See also *Note
Utility Programs::.

* Menu:

* Include problem::  A note about including <cdio/cdio.h>
* Example 1::        list out tracks and LSNs
* Example 2::        list drivers available and default CD device
* Example 3::        figure out what kind of CD (image) we've got
* Example 4::        use libiso9660 to extract a file from an ISO-9660 image
* Example 5::        list CD-Text and CD disc mode info
* Example 6::        run a MMC INQUIRY command
* Example 7::        using the CD Paranoia library for CD-DA reading
* Example 8::        Setting output verbosity
* All sample programs:: list of all programs in the example directory


File: libcdio.info,  Node: Include problem,  Next: Example 1,  Up: How to use

7.1 A note about including '<cdio/cdio.h>'
==========================================

libcdio installs '<cdio/cdio_config.h>'.  This file contains all of the
C Preprocessor values from 'config.h' (created by configure).

This header can be used to consult exactly how libcdio was built.
Initially I had selected "interesting" values, but this became too hard
to maintain.

One set of values that libdio needs internally is the whether the CPU
that was used to compile libcdio is BigEndian or not; it can get this
from libcdio's 'config.h' which is not installed and preferred or
'cdio/cdio_config.h'.

Some of the libcdio programs like the demo programs include 'config.h'
for the generic reasons that the configuration-created 'config.h' file
is used: to figure out what headers are available.  For example, do we
have '<unistd.h>'?

The file 'config.h' is generated by an autotools-generated 'configure'
script.  It doesn't check to see if it has been included previously.

Later, the demo programs include '<cdio.h>' to get libcdio headers.  But
because libcdio needs some of the same information like the BigEndian
value, this creates a duplicate include.

The way I get around this in the demo programs is by defining
'__CDIO_CONFIG_H__' after including 'config.h' as follows:

     #ifdef HAVE_CONFIG_H
     # include "config.h"
     # define __CDIO_CONFIG_H__ 1
     #endif

Applications using libcdio may find it handy to do something like this
as well.

Defining '__CDIO_CONFIG_H__' will make sure 'config_cdio.h' which is
internally used, doesn't try to redefine preprocessor symbols.

Ok.  But now what about the problem that there are common preprocessor
symbols in 'config_cdio.h' that an application may want to define in a
different manner, like 'PACKAGE_NAME'?

For this, there is yet another header, '<cdio/cdio_unconfig.h>'.  This
file undefines any symbol that 'config.h' defines.  And now we bounce to
the problem that there may be symbols that are normally defined
('HAVE_UNISTD_H') and you want to keep that way, but others that you
don't.  So here is what I suggest:

       // for cdio:
       #include <cdio.h>
       #include <cdio_unconfig.h> # remove *all* symbols libcdio defines

       // Add back in the ones you want your program
       #include <config.h>

The solution isn't the most simple or natural, but programming sometimes
can be difficult.  If someone has a better solution, let me know.

Between header files 'cdio_config.h' and 'cdio_unconfig.h' and all the
fact that almost all headers(1) define a symbol to indicate they have
been included, I think there is enough mechanism to cover most
situations that may arise.

   ---------- Footnotes ----------

   (1) '<cdio_unconfig.h>' is one of the few headers that doesn't set a
preprocessor symbol: it does its thing every time it is '#included'


File: libcdio.info,  Node: Example 1,  Next: Example 2,  Prev: Include problem,  Up: How to use

7.2 Example 1: list out tracks and LSNs
=======================================

Here we will give an annotated example which can be found in the
distribution as 'example/tracks.c'.

      1: #include <stdio.h>
      2: #include <sys/types.h>
      3: #include <cdio/cdio.h>
      4: int
      5: main(int argc, const char *argv[])
      6: {
      7:  CdIo_t *p_cdio = cdio_open ("/dev/cdrom", DRIVER_DEVICE);
      8:  track_t first_track_num = cdio_get_first_track_num(p_cdio);
      9:  track_t i_tracks        = cdio_get_num_tracks(p_cdio);
     10:  int j, i=first_track_num;
     11:
     12:  printf("CD-ROM Track List (%i - %i)\n", first_track_num, i_tracks);
     13
     14:  printf("  #:  LSN\n");
     15:
     16:  for (j = 0; j < i_tracks; i++, j++) {
     17:    lsn_t lsn = cdio_get_track_lsn(p_cdio, i);
     18:    if (CDIO_INVALID_LSN != lsn)
     19:      printf("%3d: %06d\n", (int) i, lsn);
     20:  }
     21:  printf("%3X: %06d  leadout\n", CDIO_CDROM_LEADOUT_TRACK,
     22:         cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK));
     23:  cdio_destroy(p_cdio);
     24:  return 0;
     25: }

Already from the beginning on line 2 we see something odd.  The
'#include <sys/types.h>' is needed because 'libcdio' assumes type
definitions exist for 'uint32_t', 'uint16_t' and so on.  Alternatively
you change line 2 to:

     #define HAVE_SYS_TYPES_H

and '<cdio/cdio.h>' will insert line 2.  If you use GNU autoconf to
configure your program, add 'sys/types.h' to 'AC_HAVE_HEADERS' and _it_
will arrange for 'HAVE_SYS_TYPES_H' to get defined.  If you don't have
'<sys/types.h>' but have some other include that defines these types,
put that instead of line 2.  Or you could roll your own typedefs.
(Note: In the future, this will probably get "fixed" by requiring
glib.h.)

Okay after getting over the hurdle of line 2, the next line pretty
straightforward: you need to include this to get cdio definitions.  One
of the types that is defined via line 3 is 'CdIo_t' and a pointer that
is used pretty much in all operations.  Line 6 initializes the variable
'cdio' which we will be using in all of the subsequent libcdio calls.
It does this via a call to 'cdio_open()'.

The second parameter of 'cdio_open' is DRIVER_UNKNOWN. For any given
installation a number of Compact Disc device drivers may be available.
In particular it's not uncommon to have several drivers that can read CD
disk-image formats as well as a driver that handles some CD-ROM piece of
hardware.  Using DRIVER_UNKNOWN as that second parameter we let the
library select a driver amongst those that are available; generally the
first hardware driver that is available is the one selected.

If there is no CD in any of the CD-ROM drives or one does not have
access to the CD-ROM, it is possible that 'libcdio' will find a CD image
in the directory you run this program and will pick a suitable CD-image
driver.  If this is not what you want, but always want some sort of
CD-ROM driver (or failure if none), then use DRIVER_DEVICE instead of
DRIVER_UNKNOWN.

Note that in contrast to what is typically done using ioctls to read a
CD, you don't issue any sort of CD-ROM read TOC command--that is all
done by the driver.  Of course, the information that you get from
reading the TOC is often desired: many tracks are on the CD, or what
number the first one is called.  This is done through calls on lines 8
and 9.

For each track, we call a cdio routine to get the logical sector number,
'cdio_get_track_lsn()' on line 17 and print the track number and LSN
value.  Finally we print out the "lead-out track" information and we
finally call 'cdio_destroy()' in line 23 to indicate we're done with the
CD.


File: libcdio.info,  Node: Example 2,  Next: Example 3,  Prev: Example 1,  Up: How to use

7.3 Example 2: list drivers available and default CD device
===========================================================

One thing that's a bit hockey in Example 1 is hard-coding the name of
the device used: '/dev/cdrom'.  Although often this is the name of a
CD-ROM device on GNU/Linux and possibly some other Unix derivatives,
there are many OSs for which use a different device name.

In the next example, we'll let the driver give us the name of the CD-ROM
device that is right for it.

      1: #include <stdio.h>
      2: #include <sys/types.h>
      3: #include <cdio/cdio.h>
      4: int
      5: main(int argc, const char *argv[])
      6: {
      7:   CdIo_t *p_cdio = cdio_open (NULL, DRIVER_DEVICE);
      8:   const driver_id_t *driver_id_p;
      9:
     10:  if (NULL != p_cdio) {
     11:    printf("The driver selected is %s\n", cdio_get_driver_name(p_cdio));
     12:    printf("The default device for this driver is %s\n\n",
     13:           cdio_get_default_device(p_cdio));
     14:    cdio_destroy(p_cdio);
     15:  } else {
     16:    printf("Problem in trying to find a driver.\n\n");
     17:  }
     18:
     19:  for (driver_id_p=cdio_drivers; *driver_id_p!=DRIVER_UNKNOWN; driver_id_p++)
     20:    if (cdio_have_driver(*driver_id_p))
     21:      printf("We have: %s\n", cdio_driver_describe(*driver_id_p));
     22:    else
     23:      printf("We don't have: %s\n", cdio_driver_describe(*driver_id_p));
     24:  return 0;
     25: }


File: libcdio.info,  Node: Example 3,  Next: Example 4,  Prev: Example 2,  Up: How to use

7.4 Example 3: figure out what kind of CD (image) we've got
===========================================================

In this example is a somewhat simplified program to show the use of
'cdio_guess_cd_type()' to figure out the kind of CD image we've got.
This can be found in the distribution as 'example/sample3.c'.

     #ifdef HAVE_CONFIG_H
     # include "config.h"
     #endif
     #include <stdio.h>
     #include <string.h>
     #include <sys/types.h>
     #include <cdio/cdio.h>
     #include <cdio/cd_types.h>

     static void
     print_analysis(cdio_iso_analysis_t cdio_iso_analysis,
     	       cdio_fs_anal_t fs, int first_data, unsigned int num_audio,
     	       track_t i_tracks, track_t first_track_num, CdIo_t *cdio)
     {
       switch(CDIO_FSTYPE(fs)) {
       case CDIO_FS_AUDIO:
         break;
       case CDIO_FS_ISO_9660:
         printf("CD-ROM with ISO 9660 filesystem");
         if (fs & CDIO_FS_ANAL_JOLIET) {
           printf(" and joliet extension level %d", cdio_iso_analysis.joliet_level);
         }
         if (fs & CDIO_FS_ANAL_ROCKRIDGE)
           printf(" and rockridge extensions");
         printf("\n");
         break;
       case CDIO_FS_ISO_9660_INTERACTIVE:
         printf("CD-ROM with CD-RTOS and ISO 9660 filesystem\n");
         break;
       case CDIO_FS_HIGH_SIERRA:
         printf("CD-ROM with High Sierra filesystem\n");
         break;
       case CDIO_FS_INTERACTIVE:
         printf("CD-Interactive%s\n", num_audio > 0 ? "/Ready" : "");
         break;
       case CDIO_FS_HFS:
         printf("CD-ROM with Macintosh HFS\n");
         break;
       case CDIO_FS_ISO_HFS:
         printf("CD-ROM with both Macintosh HFS and ISO 9660 filesystem\n");
         break;
       case CDIO_FS_UFS:
         printf("CD-ROM with Unix UFS\n");
         break;
       case CDIO_FS_EXT2:
         printf("CD-ROM with Linux second extended filesystem\n");
     	  break;
       case CDIO_FS_3DO:
         printf("CD-ROM with Panasonic 3DO filesystem\n");
         break;
       case CDIO_FS_UNKNOWN:
         printf("CD-ROM with unknown filesystem\n");
         break;
       }
       switch(CDIO_FSTYPE(fs)) {
       case CDIO_FS_ISO_9660:
       case CDIO_FS_ISO_9660_INTERACTIVE:
       case CDIO_FS_ISO_HFS:
         printf("ISO 9660: %i blocks, label `%.32s'\n",
     	   cdio_iso_analysis.isofs_size, cdio_iso_analysis.iso_label);
         break;
       }
       if (first_data == 1 && num_audio > 0)
         printf("mixed mode CD   ");
       if (fs & CDIO_FS_ANAL_XA)
         printf("XA sectors   ");
       if (fs & CDIO_FS_ANAL_MULTISESSION)
         printf("Multisession");
       if (fs & CDIO_FS_ANAL_HIDDEN_TRACK)
         printf("Hidden Track   ");
       if (fs & CDIO_FS_ANAL_PHOTO_CD)
         printf("%sPhoto CD   ",
     		      num_audio > 0 ? " Portfolio " : "");
       if (fs & CDIO_FS_ANAL_CDTV)
         printf("Commodore CDTV   ");
       if (first_data > 1)
         printf("CD-Plus/Extra   ");
       if (fs & CDIO_FS_ANAL_BOOTABLE)
         printf("bootable CD   ");
       if (fs & CDIO_FS_ANAL_VIDEOCD && num_audio == 0) {
         printf("Video CD   ");
       }
       if (fs & CDIO_FS_ANAL_SVCD)
         printf("Super Video CD (SVCD) or Chaoji Video CD (CVD)");
       if (fs & CDIO_FS_ANAL_CVD)
         printf("Chaoji Video CD (CVD)");
       printf("\n");
     }

     int
     main(int argc, const char *argv[])
     {
       CdIo_t *p_cdio = cdio_open (NULL, DRIVER_UNKNOWN);
       cdio_fs_anal_t fs=0;

       track_t i_tracks;
       track_t first_track_num;
       lsn_t start_track;          /* first sector of track */
       lsn_t data_start =0;        /* start of data area */

       int first_data = -1;        /* # of first data track */
       int first_audio = -1;       /* # of first audio track */
       unsigned int num_data  = 0; /* # of data tracks */
       unsigned int num_audio = 0; /* # of audio tracks */
       unsigned int i;

       if (NULL == p_cdio) {
         printf("Problem in trying to find a driver.\n\n");
         return 1;
       }

       first_track_num = cdio_get_first_track_num(p_cdio);
       i_tracks      = cdio_get_num_tracks(p_cdio);

       /* Count the number of data and audio tracks. */
       for (i = first_track_num; i <= i_tracks; i++) {
         if (TRACK_FORMAT_AUDIO == cdio_get_track_format(p_cdio, i)) {
           num_audio++;
           if (-1 == first_audio) first_audio = i;
         } else {
           num_data++;
           if (-1 == first_data)  first_data = i;
         }
       }

       /* try to find out what sort of CD we have */
       if (0 == num_data) {
         printf("Audio CD\n");
       } else {
         /* we have data track(s) */
         int j;
         cdio_iso_analysis_t cdio_iso_analysis;

         memset(&cdio_iso_analysis, 0, sizeof(cdio_iso_analysis));

         for (j = 2, i = first_data; i <= i_tracks; i++) {
           lsn_t lsn;
           track_format_t track_format = cdio_get_track_format(p_cdio, i);

           lsn = cdio_get_track_lsn(p_cdio, i);

           switch ( track_format ) {
           case TRACK_FORMAT_AUDIO:
           case TRACK_FORMAT_ERROR:
     	break;
           case TRACK_FORMAT_CDI:
           case TRACK_FORMAT_XA:
           case TRACK_FORMAT_DATA:
           case TRACK_FORMAT_PSX:
     	;
           }

           start_track = (i == 1) ? 0 : lsn;

           /* save the start of the data area */
           if (i == first_data)
     	data_start = start_track;

           /* skip tracks which belong to the current walked session */
           if (start_track < data_start + cdio_iso_analysis.isofs_size)
     	continue;

           fs = cdio_guess_cd_type(p_cdio, start_track, i, &cdio_iso_analysis);

           print_analysis(cdio_iso_analysis, fs, first_data, num_audio,
     		     i_tracks, first_track_num, p_cdio);

           if ( !(CDIO_FSTYPE(fs) == CDIO_FS_ISO_9660 ||
     	     CDIO_FSTYPE(fs) == CDIO_FS_ISO_HFS  ||
     	     CDIO_FSTYPE(fs) == CDIO_FS_ISO_9660_INTERACTIVE) )
     	/* no method for non-ISO9660 multisessions */
     	break;
         }
       }
       cdio_destroy(p_cdio);
       return 0;
     }


File: libcdio.info,  Node: Example 4,  Next: Example 5,  Prev: Example 3,  Up: How to use

7.5 Example 4: use libiso9660 to extract a file from an ISO-9660 image
======================================================================

Next a program to show using 'libiso9660' to extract a file from an
ISO-9660 image.  This can be found in the distribution as
'example/isofile.c'.  A more complete and expanded version of this is
'iso-read', part of this distribution.

     /* This is the ISO 9660 image. */
     #define ISO9660_IMAGE_PATH "../"
     #define ISO9660_IMAGE ISO9660_IMAGE_PATH "test/copying.iso"

     #define LOCAL_FILENAME "copying"

     #ifdef HAVE_CONFIG_H
     # include "config.h"
     #endif

     #include <sys/types.h>
     #include <cdio/cdio.h>
     #include <cdio/iso9660.h>

     #include <stdio.h>

     #ifdef HAVE_ERRNO_H
     #include <errno.h>
     #endif
     #ifdef HAVE_STRING_H
     #include <string.h>
     #endif
     #ifdef HAVE_UNISTD_H
     #include <unistd.h>
     #endif
     #ifdef HAVE_SYS_TYPES_H
     #include <sys/types.h>
     #endif

     #define my_exit(rc)				\
       fclose (p_outfd);				\
       free(p_statbuf);				\
       iso9660_close(p_iso);				\
       return rc;					\

     int
     main(int argc, const char *argv[])
     {
       iso9660_stat_t *p_statbuf;
       FILE *p_outfd;
       int i;

       iso9660_t *p_iso = iso9660_open (ISO9660_IMAGE);

       if (NULL == p_iso) {
         fprintf(stderr, "Sorry, couldn't open ISO 9660 image %s\n", ISO9660_IMAGE);
         return 1;
       }

       p_statbuf = iso9660_ifs_stat_translate (p_iso, LOCAL_FILENAME);

       if (NULL == p_statbuf)
         {
           fprintf(stderr,
     	      "Could not get ISO-9660 file information for file %s\n",
     	      LOCAL_FILENAME);
           iso9660_close(p_iso);
           return 2;
         }

       if (!(p_outfd = fopen (LOCAL_FILENAME, "wb")))
         {
           perror ("fopen()");
           free(p_statbuf);
           iso9660_close(p_iso);
           return 3;
         }

       /* Copy the blocks from the ISO-9660 filesystem to the local filesystem. */
       for (i = 0; i < p_statbuf->size; i += ISO_BLOCKSIZE)
         {
           char buf[ISO_BLOCKSIZE];

           memset (buf, 0, ISO_BLOCKSIZE);

           if ( ISO_BLOCKSIZE != iso9660_iso_seek_read (p_iso, buf, p_statbuf->lsn
     						   + (i / ISO_BLOCKSIZE),
     						   1) )
           {
     	fprintf(stderr, "Error reading ISO 9660 file at lsn %lu\n",
     		(long unsigned int) p_statbuf->lsn + (i / ISO_BLOCKSIZE));
     	my_exit(4);
           }


          fwrite (buf, ISO_BLOCKSIZE, 1, p_outfd);

          if (ferror (p_outfd))
             {
               perror ("fwrite()");
               my_exit(5);
             }
         }

       fflush (p_outfd);

       /* Make sure the file size has the exact same byte size. Without the
          truncate below, the file will a multiple of ISO_BLOCKSIZE.
        */
       if (ftruncate (fileno (p_outfd), p_statbuf->size))
         perror ("ftruncate()");

       my_exit(0);
     }


File: libcdio.info,  Node: Example 5,  Next: Example 6,  Prev: Example 4,  Up: How to use

7.6 Example 5: list CD-Text and disc mode info
==============================================

Next a program to show using 'libcdio' to list CD-TEXT data.  This can
be found in the distribution as 'example/cdtext.c'.

     /* Simple program to list CD-Text info of a Compact Disc using libcdio. */
     #ifdef HAVE_CONFIG_H
     # include "config.h"
     #endif
     #include <stdio.h>
     #include <sys/types.h>
     #include <cdio/cdio.h>
     #include <cdio/cdtext.h>


     static void
     print_cdtext_track_info(CdIo_t *p_cdio, track_t i_track, const char *message) {
       const cdtext_t *cdtext    = cdio_get_cdtext(p_cdio, 0);
       if (NULL != cdtext) {
         cdtext_field_t i;

         printf("%s\n", message);

         for (i=0; i < MAX_CDTEXT_FIELDS; i++) {
           if (cdtext->field[i]) {
             printf("\t%s: %s\n", cdtext_field2str(i), cdtext->field[i]);
           }
         }
       }

     }

     static void
     print_disc_info(CdIo_t *p_cdio, track_t i_tracks, track_t i_first_track) {
       track_t i_last_track = i_first_track+i_tracks;
       discmode_t cd_discmode = cdio_get_discmode(p_cdio);

       printf("%s\n", discmode2str[cd_discmode]);

       print_cdtext_track_info(p_cdio, 0, "\nCD-Text for Disc:");
       for ( ; i_first_track < i_last_track; i_first_track++ ) {
         char psz_msg[50];
         sprintf(msg, "CD-Text for Track %d:", i_first_track);
         print_cdtext_track_info(p_cdio, i_first_track, psz_msg);
       }
     }

     int
     main(int argc, const char *argv[])
     {
       track_t i_first_track;
       track_t i_tracks;
       CdIo_t *p_cdio;
       cdio = cdio_open (NULL, DRIVER_UNKNOWN);
       i_first_track = cdio_get_first_track_num(p_cdio);
       i_tracks      = cdio_get_num_tracks(p_cdio);

       if (NULL == p_cdio) {
         printf("Couldn't find CD\n");
         return 1;
       } else {
         print_disc_info(p_cdio, i_tracks, i_first_track);
       }

       cdio_destroy(p_cdio);

       return 0;
     }


File: libcdio.info,  Node: Example 6,  Next: Example 7,  Prev: Example 5,  Up: How to use

7.7 Example 6: Using MMC to run an 'INQURY' command
===================================================

Now a program to show issuing a simple MMC command ('INQUIRY').  This
MMC command retrieves the vendor, model and firmware revision number of
a CD drive.  For this command to work, usually a CD to be loaded into
the drive; odd since the CD itself is not used.

This can be found in the distribution as 'example/mmc1.c'.

     #ifdef HAVE_CONFIG_H
     # include "config.h"
     # define __CDIO_CONFIG_H__ 1 /* assumes config.h is libcdio's config.h /
     #endif
     #include <stdio.h>
     #include <sys/types.h>
     #include <cdio/cdio.h>
     #include <cdio/scsi_mmc.h>
     #include <string.h>

     /* Set how long to wait for MMC commands to complete */
     #define DEFAULT_TIMEOUT_MS 10000

     int
     main(int argc, const char *argv[])
     {
       CdIo_t *p_cdio;

       p_cdio = cdio_open (NULL, DRIVER_UNKNOWN);

       if (NULL == p_cdio) {
         printf("Couldn't find CD\n");
         return 1;
       } else {
         int i_status;                  /* Result of MMC command */
         char buf[36] = { 0, };         /* Place to hold returned data */
         scsi_mmc_cdb_t cdb = {{0, }};  /* Command Descriptor Buffer */

         CDIO_MMC_SET_COMMAND(cdb.field, CDIO_MMC_GPCMD_INQUIRY);
         cdb.field[4] = sizeof(buf);

         i_status = scsi_mmc_run_cmd(p_cdio, DEFAULT_TIMEOUT_MS,
     				&cdb, SCSI_MMC_DATA_READ,
     				sizeof(buf), &buf);
         if (i_status == 0) {
           char psz_vendor[CDIO_MMC_HW_VENDOR_LEN+1];
           char psz_model[CDIO_MMC_HW_MODEL_LEN+1];
           char psz_rev[CDIO_MMC_HW_REVISION_LEN+1];

           memcpy(psz_vendor, buf + 8, sizeof(psz_vendor)-1);
           psz_vendor[sizeof(psz_vendor)-1] = '\0';
           memcpy(psz_model,
     	     buf + 8 + CDIO_MMC_HW_VENDOR_LEN,
     	     sizeof(psz_model)-1);
           psz_model[sizeof(psz_model)-1] = '\0';
           memcpy(psz_rev,
     	     buf + 8 + CDIO_MMC_HW_VENDOR_LEN +CDIO_MMC_HW_MODEL_LEN,
     	     sizeof(psz_rev)-1);
           psz_rev[sizeof(psz_rev)-1] = '\0';

           printf("Vendor: %s\nModel: %s\nRevision: %s\n",
     	     psz_vendor, psz_model, psz_rev);
         } else {
           printf("Couldn't get INQUIRY data (vendor, model, and revision\n");
         }
       }

       cdio_destroy(p_cdio);

       return 0;
     }

Note the include of '#define' of '__CDIO_CONFIG_H__' towards the
beginning.  This is useful if the prior '#include' of 'config.h' refers
to libcdio's configuration header.  It indicates that libcdio's
configuration settings have been used.  Without it, you may get messages
about C Preprocessor symbols getting redefined in the '#include' of
'<cdio.cdio.h>'.


File: libcdio.info,  Node: Example 7,  Next: Example 8,  Prev: Example 6,  Up: How to use

7.8 Example 7: Using the CD Paranoia library for CD-DA reading
==============================================================

The below program reads CD-DA data.  For a more complete program to add
a WAV header so that the CD can be played from a copy on a hard disk,
see the corresponding distribution program.

This can be found in the distribution as 'example/paranoia.c'.

     #ifdef HAVE_CONFIG_H
     # include "config.h"
     # define __CDIO_CONFIG_H__ 1 /* assumes config.h is libcdio's config.h /
     #endif

     #include <cdio/cdda.h>
     #include <cdio/cd_types.h>
     #include <stdio.h>

     #ifdef HAVE_STDLIB_H
     #include <stdlib.h>
     #endif

     int
     main(int argc, const char *argv[])
     {
       cdrom_drive_t *d = NULL; /* Place to store handle given by cd-paranoia. */
       char **ppsz_cd_drives;   /* List of all drives with a loaded CDDA in it. */

       /* See if we can find a device with a loaded CD-DA in it. */
       ppsz_cd_drives = cdio_get_devices_with_cap(NULL, CDIO_FS_AUDIO, false);

       if (ppsz_cd_drives) {
         /* Found such a CD-ROM with a CD-DA loaded. Use the first drive in
            the list. */
         d=cdio_cddap_identify(*ppsz_cd_drives, 1, NULL);
       } else {
         printf("Unable find or access a CD-ROM drive with an audio CD in it.\n");
         exit(1);
       }

       /* Don't need a list of CD's with CD-DA's any more. */
       cdio_free_device_list(ppsz_cd_drives);

       /* We'll set for verbose paranoia messages. */
       cdio_cddap_verbose_set(d, CDDA_MESSAGE_PRINTIT, CDDA_MESSAGE_PRINTIT);

       if ( 0 != cdio_cddap_open(d) ) {
         printf("Unable to open disc.\n");
         exit(1);
       }

       /* Okay now set up to read up to the first 300 frames of the first
          audio track of the Audio CD. */
       {
         cdrom_paranoia_t *p = cdio_paranoia_init(d);
         lsn_t i_first_lsn = cdio_cddap_disc_firstsector(d);

         if ( -1 == i_first_lsn ) {
           printf("Trouble getting starting LSN\n");
         } else {
           lsn_t   i_cursor;
           track_t i_track    = cdio_cddap_sector_gettrack(d, i_first_lsn);
           lsn_t   i_last_lsn = cdio_cddap_track_lastsector(d, i_track);

           /* For demo purposes we'll read only 300 frames (about 4
     	 seconds).  We don't want this to take too long. On the other
     	 hand, I suppose it should be something close to a real test.
            */
           if ( i_last_lsn - i_first_lsn > 300) i_last_lsn = i_first_lsn + 299;

           printf("Reading track %d from LSN %ld to LSN %ld\n", i_track,
     	     (long int) i_first_lsn, (long int) i_last_lsn);

           /* Set reading mode for full paranoia, but allow skipping sectors. */
           paranoia_modeset(p, PARANOIA_MODE_FULL^PARANOIA_MODE_NEVERSKIP);

           paranoia_seek(p, i_first_lsn, SEEK_SET);

           for ( i_cursor = i_first_lsn; i_cursor <= i_last_lsn; i_cursor ++) {
     	/* read a sector */
     	int16_t *p_readbuf=cdio_paranoia_read(p, NULL);
     	char *psz_err=cdio_cddap_errors(d);
     	char *psz_mes=cdio_cddap_messages(d);

     	if (psz_mes || psz_err)
     	  printf("%s%s\n", psz_mes ? psz_mes: "", psz_err ? psz_err: "");

     	if (psz_err) cdio_cddap_free_messages(psz_err);
     	if (psz_mes) cdio_cddap_free_messages(psz_mes);
     	if( !p_readbuf ) {
     	  printf("paranoia read error. Stopping.\n");
     	  break;
     	}
           }
         }
         cdio_paranoia_free(p);
       }

       cdio_cdda_close(d);
       exit(0);
     }

Those who are die-hard cdparanoia programmers will notice that the
'libcdio' paranoia names are similar but a little bit different.  In
particular instead of 'paranoia_read' we have above 'cdio_paranoia_read'
and instead of 'cdda_open' we have 'cdio_cddap_open'.

This was done intentionally so that it is possible for the original
paranoia program can co-exist both in source code and linked libraries
and not conflict with 'libcdio''s paranoia source and libraries.

In general in place of any paranoia routine that begins 'paranoia_', use
'cdio_paranoia_' and in place of any paranoia routine that begins
'cdda_', use 'cdio_cddap_'.  But for a limited time 'libcdio' will
accept the old paranoia names which may be useful for legacy paranoia
code.  The way this magic works is by defining the old paranoia name to
be the 'libcdio' name.

In the unusual case where you do want to use both the original paranoia
and 'libcdio' routines in a single source, the C preprocessor symbol
'DO_NOT_WANT_PARANOIA_COMPATIBILITY' can be 'define''d and this disables
the '#define' substitution done automatically.  The may still be a
problem with conflicting structure definitions like 'cdrom_drive_t'.


File: libcdio.info,  Node: Example 8,  Next: All sample programs,  Prev: Example 7,  Up: How to use

7.9 Example 8: Setting output verbosity
=======================================

Sometimes in tracking down a problem in your code or libcdio's you may
want more information about what is going on inside the 'libcdio'
library.

The setting global variable 'cdio_loglevel_default' defined in header
file '<cdio/logging.h>' controls the verbosity level.  By default, only
warnings, errors, and fatal errors are printed.  However by setting this
variable you can get either debug or informational messages, or cause
the normal messages that appear to be suppressed.

The verbosity levels defined in the library are from lowest number to
highest are:

'CDIO_LOG_DEBUG (value 1)'

     These are of a debugging nature and are give the most verbose
     output.

'CDIO_LOG_INFO (value 2)'

     These are informational message.

'CDIO_LOG_WARN (value 3)'

     These are warning message.  Not an error, per se, but something
     that might be of concern.

'CDIO_LOG_ERROR (value 4)'

     These are error messages that force program termination.

'CDIO_LOG_ASSERT (value 5)'

     These are error messages that represent an internal inconsistency
     in the 'libcdio' library.  In the absence of 'libcdio' bugs, these
     should never appear.

Setting a lower or more verbose log level will cause higher-level
messages to appear, but not those that are less than the set verbosity
level.  The "debug" level is the lowest.  So setting
'cdio_loglevel_default' to level causes all other levels of messages to
be displayed.  However setting the verbosity level to "warn" will cause
debug and informational messages (lower level messages) to be ignored
while still showing warning, error, and fatal error messages.

Another thing that can be done is to write a custom log handler that
will be used instead of 'libcdio''s default handlers.  Using this, you
have complete control of how you want logging to be handled.

Here is an example adapted from example program 'logging.c'.

     #include <stdio.h>
     #include <stdlib.h>
     #include <sys/types.h>
     #include <errno.h>
     #include <limits.h>
     #include <string.h>

     #include <cdio/cdio.h>
     #include <cdio/cd_types.h>
     #include <cdio/logging.h>

     /* Here is an example of a custom log handler. */
     static void
     custom_log_handler (cdio_log_level_t level, const char *message)
     {
       switch(level) {
       case CDIO_LOG_DEBUG:
         printf("-- custom debug message: %s\n", message);
         return;
       case CDIO_LOG_INFO:
         printf("-- custom info message: %s\n", message);
         return;
       case CDIO_LOG_WARN:
         printf("-- custom warning message: %s\n", message);
         return;
       case CDIO_LOG_ERROR:
         printf("-- custom error message: %s\n", message);
         return;
       case CDIO_LOG_ASSERT:
         printf("-- custom fatal error message: %s\n", message);
         return;
       default:
         printf("custom level %d message: %s\n", level, message);
       }
     }

     static void
     print_drives()
     {
         char **ppsz_cd_drives=NULL, **c;
         /* Print out a list of CD-drives with the above set log level. */
         ppsz_cd_drives = cdio_get_devices(DRIVER_DEVICE);
         if (NULL != ppsz_cd_drives)
     	for( c = ppsz_cd_drives; *c != NULL; c++ ) {
     	    printf("-- Drive %s\n", *c);
     	}
         cdio_free_device_list(ppsz_cd_drives);
     }

     int
     main(int argc, const char *argv[])
     {
         /* Set the log level to the warning verbosity. */
         cdio_loglevel_default = CDIO_LOG_WARN;

         print_drives();

         /* Do the same thing again but with a custom log handler. */
         cdio_log_set_handler (custom_log_handler);

         print_drives();
         return 0;

     }


File: libcdio.info,  Node: All sample programs,  Prev: Example 8,  Up: How to use

7.10 A list of all sample programs in the 'example' directory
=============================================================

The 'example' directory contains some simple examples of the use of the
'libcdio' library.

A larger more-complicated example are the 'cd-drive', 'cd-info',
'cd-read', 'iso-info' and 'iso-info' programs in the 'src' directory.

Descriptions of the sample are as follows...

'audio.c'

     A program to show audio controls.

'cdchange.c'

     A program to test if a CD has been changed since the last change
     test.

'cd-eject.c'

     A a stripped-down "eject" command to open or close a CD-ROM tray.

'cdtext.c'

     A program to show CD-Text and CD disc mode info.

'drives.c'

     A program to show drivers installed and what the default CD-ROM
     drive is and what CD drives are available.

'eject.c'

     A program eject a CD from a CD-ROM drive and then close the door
     again.

'isofile.c'

     A program to show using libiso9660 to extract a file from an
     ISO-9660 image.

'isofile2.c'

     A program to show using libiso9660 to extract a file from a CDRWIN
     cue/bin CD image.

'C++/isofile2.cpp'

     The same program as 'isofile2.c' written in C++.

'isofuzzy.c'

     A program showing fuzzy ISO-9660 detection/reading.

'isolist.c'

     A program to show using 'libiso9660' to list files in a directory
     of an ISO-9660 image.

'C++/isolist.cpp'

     The same program as 'isolist.c' written in C++.

'isofuzzy.c'

     A program showing fuzzy ISO-9660 detection/reading.

'logging.c'

     A program to show to to set log verbosity levels and how to write a
     custom log handler.

'mmc1.c'

     A program to show issuing a simple MMC command ('INQUIRY').

'C++/mmc1.cpp'

     The same program as 'mmc1.c' written in C++.

'mmc2.c'

     A more involved MMC command to list CD and drive features from a
     SCSI-MMC 'GET_CONFIGURATION' command.

'mmc2a.c'

     Prints MMC 'MODE_SENSE' page 2A parameters.  Page 2a are the CD/DVD
     Capabilities and Mechanical Status.

'C++/mmc2.cpp'

     The same program as 'mmc2.c' written in C++.

'paranoia.c'

     A program to show using libcdio's version of the CD-DA paranoia.

'paranoia2.c'

     A program to show using libcdio's version of the CD-DA paranoia
     library.  But in this version, we'll open a cdio object before
     calling paranoia's open.  I imagine in many cases such as media
     players this may be what will be done since, one may want to get
     CDDB/CD-Text info beforehand.

'tracks.c'

     A simple program to list track numbers and logical sector numbers
     of a Compact Disc using 'libcdio'.

'sample2.c'

     A simple program to show drivers installed and what the default
     CD-ROM drive is.

'sample3.c'

     A simple program to show the use of 'cdio_guess_cd_type()'.
     Figures out the kind of CD image we've got.

'sample4.c'

     A slightly improved sample3 program: we handle cdio logging and
     take an optional CD-location.

'udf1.c'

     A program to show using libudf to list files in a directory of an
     UDF image.

'udf2.c'

     A program to show using libudf to extract a file from an UDF image.


File: libcdio.info,  Node: Utility Programs,  Next: CD-ROM Access and Drivers,  Prev: How to use,  Up: Top

8 Diagnostic programs: 'cd-drive', 'cd-info', 'cd-read', 'iso-info', 'iso-read'
*******************************************************************************

* Menu:

* cd-drive::       list out CD-ROM drive information
* cd-info::        list out CD or CD-image information
* cd-read::        read blocks of a CD or CD image
* iso-info::       list out ISO-9600 image information
* iso-read::       extract a file from an ISO 9660 image


File: libcdio.info,  Node: cd-drive,  Next: cd-info,  Up: Utility Programs

8.1 'cd-drive'
==============

'cd-drive' lists out drive information, what features drive supports,
and information about what hardware drivers are available.


File: libcdio.info,  Node: cd-info,  Next: cd-read,  Prev: cd-drive,  Up: Utility Programs

8.2 'cd-info'
=============

'cd-info' will print out the structure of a CD medium which could either
be a Compact Disc in a CD ROM or an CD image.  It can try to analyze the
medium to give characteristics of the medium, such as how many tracks
are in the CD and the format of each track, whether a CD contains a
Video CD, CD-DA, PhotoCD, whether a track has an ISO-9660 filesystem.


File: libcdio.info,  Node: cd-read,  Next: iso-info,  Prev: cd-info,  Up: Utility Programs

8.3 'cd-read'
=============

'cd-info' can be used to read blocks a CD medium which could either be a
Compact Disc in a CD ROM or an CD image.  You specify the beginning and
ending LSN and what mode format to use in the reading.


File: libcdio.info,  Node: iso-info,  Next: iso-read,  Prev: cd-read,  Up: Utility Programs

8.4 'iso-info'
==============

'iso-info' can be used to print out the structure of an ISO 9660 image.


File: libcdio.info,  Node: iso-read,  Prev: iso-info,  Up: Utility Programs

8.5 'iso-read'
==============

'iso-read' can be used to extract a file in an ISO-9660 image.


File: libcdio.info,  Node: CD-ROM Access and Drivers,  Next: Internal Program Organization,  Prev: Utility Programs,  Up: Top

9 CD-ROM Access and Drivers
***************************

* Menu:

* SCSI mess::  SCSI, SCSI commands, and MMC commands
* Access Modes::  Access Modes
* Accessing Driver Parameters:: Accessing Driver Parameters

* GNU/Linux:: GNU/Linux ioctl
* Microsoft:: Microsoft Windows ioctl and ASPI
* Solaris:: Solaris ATAPI and SCSI
* FreeBSD:: FreeBSD ioctl and CAM
* OS X::  OSX (non-exclussive access)


File: libcdio.info,  Node: SCSI mess,  Next: Access Modes,  Up: CD-ROM Access and Drivers

9.1 SCSI, SCSI commands, and MMC commands
=========================================

Historically, SCSI referred to a class of hardware devices and device
controllers, bus technology and the data cables and protocols which
attached to such devices.  This is now called "Parallel SCSI".

A specification standard grew out of the _commands_ that controlled such
SCSI devices, but now covers a wider variety of bus technologies
including Parallel SCSI, ATA/ATAPI, Serial ATA, Universal Serial Bus
(USB versions 1.1 and 2.0), and High Performance Serial Bus (IEEE 1394,
1394A, and 1394B).

Another similar class of hardware devices and controllers is called ATA
and a command interface to that is called ATAPI (ATA Packetized
Interface).  ATAPI provides a mechanism for transferring and executing
SCSI commands.

MMC (Multimedia commands) is a specification which adds special SCSI
commands for CD, DVD, Blu-Ray devices.

If your optical drive understands MMC commands as most do nowadays, this
probably gives the most flexibility in control.  SCSI and ATAPI CD-ROM
devices generally support a fairly large set of MMC commands.
Unfortunately, on most Operating Systems one may need to do some
additional setup, such as install drivers or modules, to allow access in
this manner.

The name "SCSI MMC" is often found in the literature in specifications
and on the Internet.  The "SCSI" part is probably a little bit
misleading because a drive can understand "SCSI MMC" commands but not
use a SCSI bus protocol--ATAPI CD-ROMs are one such broad class of
examples.  In fact there are drivers to "encapsulate" non-SCSI drives to
make them act like more like SCSI drives, such as by adding SCSI address
naming.

For clarity and precision we will use the term "MMC" rather than "SCSI
MMC".

One of the problems with MMC is that there are so many different
"standards".  In particular:
   * MMC -- <ftp://ftp.t10.org/t10/drafts/mmc/>,
   * MMC 2 -- <ftp://ftp.t10.org/t10/drafts/mmc2/>
   * MMC 3 -- <ftp://ftp.t10.org/t10/drafts/mmc3/>
   * MMC 4 -- <ftp://ftp.t10.org/t10/drafts/mmc4/>
   * MMC 5 -- <ftp://ftp.t10.org/t10/drafts/mmc5/>
along with the several "drafts" of these.

Another problem with the MMC commands related to the variations in
standards is the variation in the commands themselves and there are
perhaps two or three ways to do many of the basic commands like read a
CD frame.

There seems to be a fascination with the number of bytes a command takes
in the MMC-specification world.  (Size matters?)  So often the name of
an operation will have a suffix with the number of bytes of the command
(actually in MMC jargon this is called a "CDB" or command descriptor
block).  So for example there is a 6-byte "MODE SELECT" often called
"MODE SELECT 6" and a 10-byte "MODE SELECT" often called "MODE SELECT
10".  Presumably the 6-byte command came first and it was discovered
that there was some deficiency causing the longer command.  In 'libcdio'
where there are two formats we add the suffix in the name, e.g.
'CDIO_MMC_GPCMD_MODE_SELECT_6' or 'CDIO_MMC_GPCMD_MODE_SELECT_10'.

If the fascination and emphasis in the MMC specifications of CDB size is
a bit odd, equally so is the fact that this too often has bled through
at the OS programming API. However in 'libcdio', you just give the
opcode in 'scsi_mmc_run_cmd()' and we'll do the work to figure out how
many bytes of the CDB are used.

Down the line it is hoped that 'libcdio' will have a way to remove a
distinction between the various alternative and alternative-size MMC
commands.  In 'cdio/scsi-mmc.h' you will find a little bit of this for
example via the routine 'scsi_mmc_get_drive_cap()'.  However much more
work is needed.

Finally, in 'libcdio' there is a driver access mode (not a driver)
called "MMC". It tells the specific drivers to use MMC commands instead
of other OS-specific mechanisms.


File: libcdio.info,  Node: Access Modes,  Next: Accessing Driver Parameters,  Prev: SCSI mess,  Up: CD-ROM Access and Drivers

9.2 Access Modes
================

There are serveral ways that you can open a CD-ROM drive for subsequent
use.  Each way is called an _access mode_.  Historically libcdio only
supported a reading kind of access.

Adding the abilty to writing to a drive for "burning" is being added by
Thomas Schmitt, and this is accomplished by opening the drive in a
read-write mode.  Currently writing modes are only supported via the MMC
command interface.  Under this, one can get exclusive read-write access
or non-exclusive read-write access.  The names of these two modes are
'MMC_RDWR_EXCL' and 'MMC_RDWR' respectively.

On various OS's often there are two kinds of read modes that are
supported, one which uses MMC commands and one which uses some sort of
OS-specific native command interface.  For example on Unix, there is
often a access mode associated with issuing an device-specific 'ioctl''s
that the OS supports.

To specify a particular kind of access mode, use 'cdio_open_am' which is
like 'cdio_open' but it requires one to specify an access mode.


File: libcdio.info,  Node: Accessing Driver Parameters,  Next: GNU/Linux,  Prev: Access Modes,  Up: CD-ROM Access and Drivers

9.3 Accessing Driver Parameters -- 'cdio_get_arg'
=================================================

Once a driver is opened, you can use call 'cdio_get_arg' to get
information about the driver.  Each driver can have specific features
that can be queried, but there are features that are common to all
drivers.  These are listed below:

'access-mode'
     This returns a string which is the name of the access mode in use.
'mmc-supported?'
     This returns a string "true" or "false" depending whether the
     driver with this access mode support MMC commands.
'scsi-tuple'
     On drivers that support MMC commands, this returns the SCSI name or
     a faked-up SCSI name that ripping front ends typically use.


File: libcdio.info,  Node: GNU/Linux,  Next: Microsoft,  Prev: Accessing Driver Parameters,  Up: CD-ROM Access and Drivers

9.4 GNU/Linux
=============

The GNU/Linux uses a hybrid of methods.  Somethings are done via ioctl
and some things via MMC. GNU/Linux has a rather nice and complete ioctl
mechanism.  On the other hand, the MMC mechanism is more universal.
There are other "access modes" listed which are not really access modes
and should probably be redone/rethought.  They are just different ways
to run the read command.  But for completeness These are "READ_CD" and
"READ_10".

Writing/burning to a drive is supported via access modes 'MMC_RDWR_EXCL'
or 'MMC_RDWR'.


File: libcdio.info,  Node: Microsoft,  Next: Solaris,  Prev: GNU/Linux,  Up: CD-ROM Access and Drivers

9.5 Microsoft Windows ioctl and ASPI
====================================

There are two CD drive access methods on Microsoft Windows platforms:
ioctl and ASPI.

The ASPI interface specification was developed by Adaptec for sending
commands to a SCSI host adapter (such as those controlling CD and DVD
drives) and used on Window 9x/NT and later.  Emulation for ATAPI drives
was added so that the same sets of commands worked those even though the
drives might not be SCSI nor might there even be a SCSI controller
attached.  The DLL is not part of Microsoft Windows and has to be
downloaded and installed separately.

However in Windows NT/2K/XP, Microsoft provides their Win32 ioctl
interface, and has taken steps to make using ASPI more inaccessible
(e.g.  requiring administrative access to use ASPI).


File: libcdio.info,  Node: Solaris,  Next: FreeBSD,  Prev: Microsoft,  Up: CD-ROM Access and Drivers

9.6 Solaris ATAPI and SCSI
==========================

There is currently only one CD drive access methods in Solaris: SCSI
(called "USCSI" or "user SCSI" in Solaris).  There used to be an ATAPI
method and it could be resurrected if needed.  USCSI was preferred since
on newer releases of Solaris and Solaris environments one need to have
root access for ATAPI.


File: libcdio.info,  Node: FreeBSD,  Next: OS X,  Prev: Solaris,  Up: CD-ROM Access and Drivers

9.7 FreeBSD ioctl and CAM
=========================

There are two classes of access methods on FreeBSD: ioctl and CAM
(common access method).  CAM is preferred when possible, especially on
newer releases.  However CAM is right now sort of a hybrid and includes
some ioctl code.

Writing/burning to a drive is supported via access modes 'MMC_RDWR_EXCL'
or 'MMC_RDWR' which underneath use CAM access.


File: libcdio.info,  Node: OS X,  Prev: FreeBSD,  Up: CD-ROM Access and Drivers

9.8 OS X (non-exclusive access)
===============================

A problem with libcdio on OS/X is that if the OS thinks it understands
the drive, it will get exclusive access to the drive and thus prevents a
library like this from obtaining non-exclusive access.

Currently 'libcdio' access the CD-ROM non-exclusively.  However in order
to be able to issue MMC, the current belief is that exclusive access is
needed.  Probably in a future 'libcdio', there will be some way to
specify which kind of access is desired (with the inherent consequences
of each).

More work on this driver is needed.  Volunteers?


File: libcdio.info,  Node: Internal Program Organization,  Next: ISO-9660 Character Sets,  Prev: CD-ROM Access and Drivers,  Up: Top

10 Internal Program Organization
********************************

* Menu:

* File Organization::
* Library Organization::
* Programming Conventions::


File: libcdio.info,  Node: File Organization,  Next: Library Organization,  Up: Internal Program Organization

10.1 File Organization
======================

Here is a list of 'libcdio' directories.

   * 'include/cdio'

     This contains the headers that are public.  One that will probably
     be used quite a bit is '<cdio/cdio.h>'.

   * 'lib'

     Code for installed libraries.  See below for further breakout

   * 'lib/driver'

     Code for various OS-specific CD-ROM drivers, image drivers, and
     common MMC routines.

     This code comprises 'libcdio.a' (or the shared version of it).

   * 'lib/iso9660'

     Code for to extract or query ISO-9660 images.

     This code comprises 'libiso9660.a' (or the shared version of it).

   * 'lib/paranoia'

     This is from cdparanoia.  It is the OS- and hardware- dependent
     code to detect and correct jitter for CD-DA CDs.

   * 'lib/cdda_interface'

     This is also from cdparanoia.  It is the OS- and hardware-
     independent code to detect and correct jitter for CD-DA CDs.

   * 'doc'

     A home for fine documentation such as this masterpiece.

   * 'example'

     Here you will find various small example programs using 'libcdio'
     which are largely for pedagogical purposes.  You might be able to
     find one that is similar to what you want to do that could be
     extended.  In fact some these are contain the kernel ideas behind
     of some of the larger programs in 'src'.

   * 'src'

     Various stand-alone utility programs.  See below.

   * 'src/paranoia'

     'libcdio''s version of 'cdparanoia'.  Except for the fact that the
     back-end CD-reading code has been replaced by 'libcdio''s routines
     the code is pretty much identical.

   * 'test'

     Regression tests

   * 'test/data'

     Disk images and image meta-data used in tests

   * 'test/driver'

     Unit tests centered around the libcdio library ('libcdio', source
     location 'lib/driver'


File: libcdio.info,  Node: Library Organization,  Next: Programming Conventions,  Prev: File Organization,  Up: Internal Program Organization

10.2 Library Organization
=========================

* Menu:

* libcdio::
* libcdio_cdda:: Access to CD-DA via the CD Paranoia library
* libcdio_paranoia:: Access to the CD Paranoia library
* libiso9660::  Access to ISO 9660 file systems and structures
* libudf:: Access to UDF file systems and structures


File: libcdio.info,  Node: libcdio,  Next: libcdio_cdda,  Up: Library Organization

10.2.1 'libcdio'
----------------

'libcdio' exports one opaque type 'CdIo_t'.  Internally this a structure
containing an enumeration for the driver, a structure containing
function pointers and a generic "environment" pointer which is passed as
a parameter on a function call.  See 'lib/driver/cdio_private.h'.  The
initialization routine for each driver sets up the function pointers and
allocates memory for the environment.  When a particular user-level cdio
routine is called (e.g 'cdio_get_first_track_num' for
lib/driver/track.c), the environment pointer is passed to a
device-specific routine which will then cast this pointer into something
of the appropriate type.

Because function pointers are used, there can be and is quite a bit of
sharing of common routines.  Some of the common routines are found in
the file 'lib/driver/_cdio_generic.c'.

Another set of routines that one is likely to find shared amongst
drivers are the MMC commands.  These are located in
'lib/driver/scsi_mmc.c'.

There is not only an attempt to share functions but we've tried to
create a generic CD structure 'generic_img_private_t' of file
'lib/driver/generic.h'.  By putting information into a common structure,
we increase the likelihood of being able to have a common routine to
perform some sort of function.

The generic CD structure would also be useful in a utility to convert
one CD-image format to another.  Basically the first image format is
"parsed" into the common internal format and then from this structure it
is not parsed.


File: libcdio.info,  Node: libcdio_cdda,  Next: libcdio_paranoia,  Prev: libcdio,  Up: Library Organization

10.2.2 'libcdio_cdda'
---------------------

This library is intended to give access CD-DA disks using Monty's
cd-paranoia library underneath.

To be completed....


File: libcdio.info,  Node: libcdio_paranoia,  Next: libiso9660,  Prev: libcdio_cdda,  Up: Library Organization

10.2.3 'libcdio_paranoia'
-------------------------

This library is intended to give access Monty's cd-paranoia library.  It
is the gap detection and jitter correction part without the part dealing
with CD-DA reading.

To be completed....


File: libcdio.info,  Node: libiso9660,  Next: libudf,  Prev: libcdio_paranoia,  Up: Library Organization

10.2.4 'libiso9660'
-------------------

This library is intended to give access and manipulate a ISO-9600 file
image.  One part of it is concerned with the the entire ISO-9660 file
system image, and the other part access routines for manipulating data
structures and fields that go into such an image.

To be completed....


File: libcdio.info,  Node: libudf,  Prev: libiso9660,  Up: Library Organization

10.2.5 'libudf'
---------------

This library is intended to give access and manipulate a UDF file image.

To be completed....


File: libcdio.info,  Node: Programming Conventions,  Prev: Library Organization,  Up: Internal Program Organization

10.3 Programming Conventions
============================

* Menu:

* Coding Conventions::
* Namespace Conventions::


File: libcdio.info,  Node: Coding Conventions,  Next: Namespace Conventions,  Up: Programming Conventions

10.3.1 Coding Conventions
-------------------------

In 'libcdio' there are a number of conventions used.  If you understand
some of these conventions it may facilitate understanding the code a
little.


File: libcdio.info,  Node: Namespace Conventions,  Prev: Coding Conventions,  Up: Programming Conventions

10.3.2 Namespace Conventions
----------------------------

For the most part, the visible external 'libcdio' names follow
conventions so as not to be confused with other applications or
libraries.  If you understand these conventions, there will be little or
no chance that the names you use will conflict with 'libcdio' and
'libiso9660' and vice versa.

All of the external 'libcdio' C routines start out with 'cdio_', e.g.
'cdio_open'; as a corollary, the 'libcdio' CD-Paranoia routines start
'cdio_cddap_', e.g.  'cdio_cddap_open'.  'libiso9660' routines start
'iso9660_', e.g.  'iso9660_open'.

'libcdio' C-Preprocessor names generally start 'CDIO_', for example
'CDIO_CD_FRAMESIZE_RAW'; 'libiso9660' C-preprocessor names start
'ISO9660_', e.g.  'ISO9660_FRAMESIZE'.

10.3.2.1 suffixes (type and structure names)
............................................

A few suffixes are used in type and structure names:

   * '_e'

     An enumeration tag.  Generally though the same name will appear
     with the '_t' suffix and probably that should be used instead.

   * '_s'

     A structure tag.  Generally though the same name will appear with
     the '_t' suffix and probably that should be used instead.

   * '_t'

     A type suffix.

10.3.2.2 prefixes (variable names)
..................................

A number of prefixes are used in variable names here's what they mean

   * 'i_'

     An integer type of some sort.  A variable of this ilk one might
     find being iterated over in 'for' loops or used as the index of an
     array for example.

   * 'b_'

     A Boolean type of some sort.  A variable of this ilk one might find
     being in an 'if' condition for example.

   * 'p_'

     A pointer of some sort.  A variable of this ilk, say 'p_foo' one is
     like likely to see '*p_foo' or 'p_foo->...'.

   * 'pp_'

     A pointer to a pointer of some sort.  A variable of this ilk, say
     'pp_foo' one is like likely to see '**p_foo' or 'p_foo[x][y]' for
     example

   * 'psz_'

     A 'char *' pointer of some sort.  A variable of this ilk, say
     'psz_foo' may be used in a string operation.  For example
     'printf(%s\n", psz_foo)' or 'strdup(psz_foo)'.

   * 'ppsz_'

     A pointer to a 'char *' pointer of some sort.  A variable of this
     ilk, say 'ppsz_foo' is used for example to return a list of CD-ROM
     device names

There are a some other naming conventions.  Generally if a routine name
starts 'cdio_', e.g.  'cdio_open', then it is an externally visible
routine in 'libcdio'.  If a name starts 'iso9660_', e.g.
'iso9660_is_dchar' then it is an externally visible routine in
'libiso9660'.  If a name starts 'scsi_mmc_', e.g.
'scsi_mmc_get_discmode', then it is an externally visible MMC routine.
(We don't have a separate library for this yet.

Names using entirely capital letters and that start 'CDIO_' are
externally visible '#defines'.


File: libcdio.info,  Node: ISO-9660 Character Sets,  Next: Glossary,  Prev: Internal Program Organization,  Up: Top

Appendix A ISO-9660 Character Sets
**********************************

For a description of where are used see *Note ISO 9660 Level 1::.

* Menu:

* ISO646 d-Characters::
* ISO646 a-Characters::


File: libcdio.info,  Node: ISO646 d-Characters,  Next: ISO646 a-Characters,  Up: ISO-9660 Character Sets

A.1 ISO646 d-Characters
=======================

       | 0 1 2 3 4 5 6 7
     --+-----------------
     0 |       0   P
     1 |       1 A Q
     2 |       2 B R
     3 |       3 C S
     4 |       4 D T
     5 |       5 E U
     6 |       6 F V
     7 |       7 G W
     8 |       8 H X
     9 |       9 I Y
     a |         J Z
     b |         K
     c |         L
     d |         M
     e |         N
     f |         O _


File: libcdio.info,  Node: ISO646 a-Characters,  Prev: ISO646 d-Characters,  Up: ISO-9660 Character Sets

A.2 ISO646 a-Characters
=======================

       | 0 1 2 3 4 5 6 7
     --+-----------------
     0 |       0   P
     1 |     ! 1 A Q
     2 |     " 2 B R
     3 |       3 C S
     4 |       4 D T
     5 |     % 5 E U
     6 |     & 6 F V
     7 |     ' 7 G W
     8 |     ( 8 H X
     9 |     ) 9 I Y
     a |     * : J Z
     b |     + ; K
     c |     , < L
     d |     - = M
     e |     . > N
     f |     / ? O _


File: libcdio.info,  Node: Glossary,  Next: GNU Free Documentation License,  Prev: ISO-9660 Character Sets,  Up: Top

Appendix B Glossary
*******************

Thomas Schmitt has made significant contributions to this glossary.  See
also <http://www.dvdrhelp.com/glossary>.

"ASPI"
     See Win32 ASPI

"ATA"

     Advanced Technology Attachment (ATA). The same thing as IDE.

"ATAPI"

     Advanced Technology Attachment (ATA) Packet Interface.  The
     interface provides a mechanism for transferring and executing SCSI
     CDBs on IDE CD Drives and DVD Drives.

     IDE (also called ATA) was originally designed for hard drives only,
     but with help of ATAPI it is possible to connect other devices, in
     particular CD-ROMS to the IDE/EIDE connections.

     The ATAPI CD-ROM drives understand a subset of SCSI commands.  In
     particular multi-initiator commands are neither needed nor defined
     for ATAPI devices.

"BIN/CUE"

     A CD-image format developed by Jeff Arnold for CDRWIN software on
     Microsoft Windows.  Many other programs subsequently support using
     this format.  The '.CUE' file is a text file which contains CD
     format and track layout information, while the '.BIN' file holds
     the actual data of each track.

"Blu-ray Disc (BD)"
     Optical media with capacity of 25 GB as single layer and 50 GB as
     double layer.  See also *note "Media models and profiles":
     models-profiles.

"CD"
     Compact Disc.  Capacity up to 900 MB. See also *note "Media models
     and profiles": models-profiles.

"CD-DA"
     Compact Disc Digital Audio, described in the "Red Book" or IEC
     60908 (formerly IEC 908).  This commonly referred to as an audio CD
     and what most people think of when you play a CD as it was the
     first to use the CD medium.

     See <http://en.wikipedia.org/wiki/Red_Book_(audio_CD_standard)>

"CD+G"

     Compact Disc + Graphics.  An extension of the CD audio format
     contains a limited amount of graphics in subcode channels.  This
     disc works in all audio players but the graphics portion is only
     available in a special CD+G or Karaoke player.

"CD-i"

     Compact Disc Interactive.  An extension of the CD format designed
     around a set-top computer that connects to a TV to provide
     interactive home entertainment, including digital audio and video,
     video games, and software applications.  Defined by the "Green
     Book" standard.  <http://www.icdia.org/>.  CD-i for video and video
     music has largely (if not totally) been superseded by VCDs.

"CD-i Bridge"

     A standard allowing CD-ROM XA discs to play on CD-i.  Kodak
     PhotoCDs are CD-XA Bridge discs.

"CD-ROM"

     Compact Disc Read Only Memory or "Yellow Book" describe in
     Standards ISO/IEC 10149.  The data stored on it can be either in
     the form of audio, computer or video files.

"CD-ROM Mode 1 and Mode2"

     The Yellow Book specifies two types of tracks, Mode 1 and Mode 2.
     Mode 1 is used for computer data and text and has an extra error
     correction layer.  Mode 2 is for audio and video data and has no
     extra correction layer.  CD-ROM/XA An expansion of the CD-ROM Mode
     2 format that allows both computer and audio/video to be mixed in
     the same track.

"CD Text"

     CD Text is a technology developed by Sony Corporation and Philips
     Electronics in 1996 that allows storing in an audio CD and its
     tracks information such as artist name, title, songwriter,
     composer, or arranger.  Commercially available audio CDs sometimes
     contain CD Text information.

     Information on how CD Text is stored can be found in in older MMC
     standards.  Specifically, try "Annex J" of "mmc3r10g.pdf".

     An "Unofficial CD Text FAQ" is at
     <http://web.ncf.ca/aa571/cdtext.htm>

"CD XA"

     CD-ROM EXtended Architecture.  A modification to the CD-ROM
     specification that defines two new types of sectors.  CD-ROM XA was
     developed jointly by Sony, Philips, and Microsoft, and announced in
     August 1988.  Its specifications were published in an extension to
     the Yellow Book.  CD-i, Photo CD, Video CD and CD-EXTRA have all
     subsequently been based on CD-ROM XA.

     CD-XA defines another way of formatting sectors on a CD-ROM,
     including headers in the sectors that describe the type (audio,
     video, data) and some additional info (markers, resolution in case
     of a video or audio sector, file numbers, etc).

     The data written on a CD-XA is consistent with and can be in
     ISO-9660 file system format and therefore be readable by ISO-9660
     file system translators.  But also a CD-I player can read CD-XA
     discs even if its own 'Green Book' file system only resembles ISO
     9660 and isn't fully compatible.

"DVD"
     Digital Versatile Disc.  Capacity up to 4.5 GB as single layer and
     8.5 GB as double layer media.  See also *note "Media models and
     profiles": models-profiles.

"Defect management"
     A method to compensate small amounts of bad spots on media by
     replacing them out of a pool of reserve blocks and performing
     address translation.  The necessary checkreading slows down write
     performance by a factor of 2 or 3.  Defect management applies by
     default to DVD-RAM and BD-RE. Optionally it can be formatted onto
     CD-RW and DVD+RW, where it has the name "Mount Rainier".
     Sequential BD-R can be formatted for defect management too.

"Command Packet"

     The data structure that is used to issue an ATAPI command.  It
     contains a SCSI Command Descriptor Block (CDB).

"ECMA-119 (ISO-9660)"

     (<http://www.ecma-international.org/publications/standards/Ecma-119.htm>
     is a freely available specification which is technically identical
     to ISO 9660.

"ECMA-167 (UDF)"

     (<http://www.ecma-international.org/publications/standards/Ecma-167.htm>
     is a freely available specification which is also approved as ISO
     13346.  It serves as base for UDF.

"ECMA-168"

     (<http://www.ecma-international.org/publications/standards/Ecma-168.htm>
     is a freely available specification which is also approved as ISO
     13490.

"FSF"

     Free Software Foundation, <http://www.fsf.org/>

"GNU"

     GNU is not UNIX, <http://www.gnu.org/>

"IDE"

     Integrated Drive Electronics.  This is a commonly used interface
     for hard disk drives and CD-ROM drives.  It is less expensive than
     SCSI, but offers slightly less in terms of performance.

"ISO"

     International Standards Organization.

"ISO 13346"

     ISO 13346 / ECMA-167 is a filesystem framework for data exchange on
     overwriteable or pseudo-overwriteable media.  It serves as base of
     UDF.

"ISO 13490"

     ISO 13490 / ECMA-168 is an attempt to replace ISO 9660 by a format
     that allows finer write granularity and representation of typical
     disk file properties.  It resembles ECMA-167 which led to UDF.

"ISO 9660"

     ISO 9660 / ECMA-119 is an operating-system independent filesystem
     format originally intended for CD-ROM media.  It was standardized
     in 1988 and replaced the High Sierra standard for the logical
     format on CD-ROM media (ISO 9660 and High Sierra are identical in
     content, but the exact format is different).  ISO 9660 and ECMA-119
     are technically identical meanwhile.

     There are several specification levels.  In Level 1, file names
     must be in the 8.3 format (no more than eight characters in the
     name, no more than three characters in the suffix) and in capital
     letters.  Directory names can be no longer than eight characters.
     There can be no more than eight nested directory levels.  Level 2
     and 3 specifications allow file names up to 32 characters long.
     Level 3 allows data file sizes to be 4 GB or larger.  File data
     content is stored in extents, i.e.  contiguous sequences of blocks.
     A single extent can hold only up to 2 exp 32 - 1 bytes.  So files
     of 4 GB or larger need more than one extent to be stored.  Older
     operating systems might have trouble with multi-extent files.

"Joliet extensions"

     This ISO-9660 upward-compatible standard was developed for Windows
     95 and Windows NT by Microsoft as an extension of ISO 9600 which
     allows the use of Unicode characters and supports file names up to
     64 characters.

     See <http://bmrc.berkeley.edu/people/chaffee/jolspec.html> for the
     Joliet Specification.

     The name Joliet comes from the city in Illinois (U.S) that the
     standard was defined.

"LBA"

     Logical Block Addressing.  Mapped integer numbers from CD Red Book
     Addressing MSF. The starting sector is -150 and ending sector is
     449849, which correlates directly to MSF: 00:00:00 to 99:59:74.
     Because an LBA is a single number it is often easier to work with
     in programming than an MSF.

"Lead in"

     The area of a CD where the Table Of Contents (TOC) and CD Text are
     stored.  I think it is supposed to be around 4500 (1 min) or more
     sectors in length.  On a CDR(W) the lead-in length is variable,
     because manufacturers have a different starting position indicated
     by the ATIP start of lead-in position that is recorded in the ATIP
     groove on the disk.  For example:

     "Ricoh Company Limited"
          97:27:00, 97:27:06, 97:27:66
     "Mitsubishi Chemical (Verbatim)"
          97:34:21 to 97:34:25

"LSN"

     Logical Sector Number.  Mapped integer numbers from CD Red Book
     Addressing MSF. The starting sector is 0 and ending sector is
     449699, which correlates to MSF: 00:00:00 to 99:59:74.  Because an
     LSN is a single number it is often easier to work with in
     programming than an MSF. Because it starts at 0 rather than -150 as
     is the case of an LBA it can be represented as an unsigned value.

"MCN"

     Media Catalog Number.  A identification number on an audio CD. Also
     called a UPC. Another identification number is ISRC.

"MMC"

     MMC (Multimedia Commands).

     MMC are raw commands for communicating with CDROM drives,
     CD-Rewriters, DVD-Rewriters, etc.  The are subset of the larger
     SCSI command set.  See also *note SCSI: SCSI.

     Many manufacturers have adopted this standard and it also applies
     to ATAPI versions of their drives.

     The documents 'libcdio' makes use of are described in the
     Multi-Media Commands standard (MMC). This document generally has a
     numeric level number appended.  For example MMC-5 refers to
     "Multi-Media Commands - 5.

"Media models and profiles"

     MMC classifies media as models, which describe their logical
     structure, and as profiles, which describe the capabilities of the
     drive with the particular media.  So both are closely related but
     not identical.

     There are three model families: CD, DVD, Blu-ray.  CD allows
     special sector formats like audio as well as data sectors of 2048
     bytes.  DVD and Blu-ray only record data sectors.
     "Non-writable media: CD-ROM, DVD-ROM, BD-ROM."
     "Write-once media: CD-R, DVD-R, DVD+R, BD-R."
     "Reusable media: CD-RW, DVD-RW, DVD+RW, DVD-RAM, BD-RE."

     Profiles depend on drive type and media state.  They are expressed
     as numbers.  It is unfortunate that formatted CD-RW have the same
     profile number as unformatted ones.

     ROM drives often announce all media as ROM profiles.  Some writer
     drives show closed sequential media as ROM profile.
     "CD-ROM 0x08"
     "DVD-ROM 0x10"
     "BD-ROM 0x40"

     Sequentially recordable profiles allow multisession in most cases.
     Special burn programs are needed for writing to them.
     "CD-R 0x09"
     "CD-RW 0x0a (unformatted)"
     "DVD-R 0x11"
     "DVD-RW 0x14 (unformatted)"
     "DVD-R DL 0x15 (double layer)"
     "DVD-R DL 0x16 (double layer, jump recording)"
     "DVD+R 0x1a"
     "DVD+RW DL 0x2a (double layer)"
     "DVD+R DL 0x2b (double layer)"
     "BD-R 0x41 (single or double layer, formatted or not)"
     "HD DVD-ROM 0x50"
     "HD DVD-R 0x51"
     "HD DVD-RAM 0x52"
     They can assume three states:
     ""Blank" is not readable but writeable from scratch"
     ""Appendable" is readable and after the readable part still writeable"
     ""Closed" is only readable"
     CD-RW and DVD-RW can be brought back to blank state, or they can be
     formatted to become overwriteable.

     Overwriteable profiles allow random read-write access with a
     granularity of 2 kB or 32 kB. One can hope for having read-write
     access via the normal POSIX operations lseek(), read(), write() of
     the operating system.
     "CD-RW 0x0a (formatted)"
     "DVD-RAM 0x12"
     "DVD-RW 0x13 (formatted, 32 kB write granularity)"
     "DVD+RW 0x1a"
     "BD-R 0x42 (formatted for pseudo-random recording)"
     "BD-RE 0x43 (single or double layer)"
     BD-R profile 0x42 is defined by MMC but not implemented by the
     consumer priced Blu-ray burners as of year 2010.

"Mixed Mode CD"

     A Mixed Mode is a CD that contains tracks of differing CD-ROM Mode
     formats.  In particular the first track may contain both computer
     data (Yellow Book) CD ROM data while the remaining tracks are audio
     or video data.  Video CD's can be Mixed Mode CDs.

"Multisession"

     A way of writing to a CD , DVD or Blu-ray Disc that allows more
     data to be added to readable discs at a later time.  The media must
     not have been closed by the previous write session.  This applies
     originally to unformatted CD-R, CD-RW, DVD-R, DVD-RW, DVD+R, and
     sequential BD-R which all can record more than one session.  They
     hold a table-of-content with sessions and tracks.  Formatted CD-RW,
     DVD-RAM, DVD+RW, DVD-RW, and BD-RE have only one track.
     Multisession on these media needs help by the recorded data
     formats.

     Multisession can be used to add a changeset to an existing ISO 9660
     filesystem.  Typically the add-on session contains a whole new
     filesystem tree with old and new files.  It also contains the data
     blocks of the newly introduced or freshly overwritten files.  The
     convention for mounting multisession ISO 9660 images is to load the
     superblock from the start of the first track in the last session as
     listed in the media table-of-content.  Formatted media are assumed
     to have a single track starting at block 0.  So ISO 9660
     multisession on formatted media has to overwrite the volume
     descriptors at block 16 ff.  with every new session.  A chain of
     recognizable sessions can be achieved by starting the first ISO
     9660 image at block 32 so that its descriptors get not overwritten
     later.

"Nero NRG format file"

     A proprietary CD image file format use by a popular program for
     Microsoft Windows, Ahead Nero.  The specification of this format is
     not to our knowledge published.

"Rock Ridge Extensions"

     An extension to the ISO-9660 standard which adds POSIX information
     to files.  It allows long file names, owner, group, access
     permissions 'ugo+-rwx', inode numbers, hard-link count, file types
     other than directory or regular file.  Rock Ridge is described by
     unapproved standard IEEE P1282 / RRIP-1.12 and based on unapproved
     IEEE P1281 / SUSP-1.10.  It has become a de-facto standard on
     X/Open systems like GNU/Linux, FreeBSD, Solaris, et.\ al.

"SCSI"

     Small Computer System Interface.  A set of ANSI standard electronic
     interfaces (originally developed at Apple Computer) that allow
     personal computers to communicate with peripheral hardware such as
     CD-ROM drives, disk drives, printers, etc.

     Although the original hardware is outdated since years, the SCSI
     command set nowadays controls most storage devices including all
     optical disc drives.  The contemporary electronic technologies
     which transport SCSI commands to optical drives are P-ATA, SATA,
     and USB.

     A SCSI programming specification made by the SCSI committee T10
     organization <http://www.t10.org/>.

     The documents 'libcdio' makes use of are described in SCSI
     standards documents SCSI Primary Commands (SPC), SCSI Block
     Commands (SBC), and Multi-Media Commands (MMC). These documents
     generally have a numeric level number appended.  For example SPC-3
     refers to "SCSI Primary Commands - 3'.

     In year 2010 the current versions were SPC-3, SBC-2, MMC-5.

"SCSI CDB"

     SCSI Command Descriptor Block.  The data structure that is used to
     issue a SCSI command.

"SCSI Pass Through Interface."

     Yet another way of issuing MMC commands for accessing a CD-ROM. As
     with MMC or ASPI, the CD-ROM doesn't necessarily have to be a
     SCSI-attached drive.  See also *note MMC: MMC. and *note ASPI: MMC.

"Session"

     A fully readable complete recording that contains one or more
     tracks of computer data or audio on a CD. On a DVD or Blu-ray Disc,
     there are only data sessions.

"SVCD"

     Super VCD

     An improvement of Video CD 2.0 specification which includes most
     notably a switch from MPEG-1 (constant bit rate encoding) to MPEG-2
     (variable bit rate encoding) for the video stream.

     Also added was higher video-stream resolution, up to 4 overlay
     graphics and text ("OGT") sub-channels for user switchable subtitle
     displaying, closed caption text, and command lists for controlling
     the SVCD virtual machine.

     See <http://www.dvdrhelp.com/svcd>

"TOC"

     (Compact Disc) Table of Contents.  The TOC contains a list of
     sessions and their tracks.  For sessions, it records the starting
     track number and the last track number.  For tracks it records
     starting time block address, size, copy protection, linear audio
     preemphasis, track format (CDDA or data) in that order.  Session
     and track information is also available on sequential DVD and
     Blu-ray Discs.  Several track properties are fixed to equivalents
     of CD data.

"Track"

     A unit of data of a CD. The size of a track can vary; it can occupy
     the entire contents of the CD. Most CD standards however require
     that tracks have a 150 frame (or "2 second") lead-in gap.

     An abstraction of tracks for CD, DVD and Blu-ray Discs is the
     Logical Track as of MMC specs.  Overwriteable media have a single
     logical track, sequential media can have one or more logical tracks
     which they describe in their TOC.

"UDF"

     Universal Disc Format was designed as successor of ISO 9660.  It
     allows to record long file names and advanced file properties.
     Although intended as format for data exchange its main importance
     is with DVD video players.  Video DVDs have to bear a simple UDF
     filesystem with a prescribed set of files.

"VCD"

     The Video Compact Disc ("Video CD" or "VCD") is a standardized
     digital video storage format.  It is based on the commonly
     available Compact Disc technology, which allows for low-cost video
     authoring.  Video CD's can be played in most DVD standalone player,
     dedicated VCD players and finally, modern Personal Computers with
     multimedia support.

     A Video CD is made up of CD-ROM XA sectors, i.e.  CD-ROM mode 2
     form 1 & 2 sectors.  Non-MPEG data is stored in mode 2 form 1
     sectors with a user data area of 2048 byte, which have a similar L2
     error correction and detection (ECC/EDC) to CD-ROM mode 1 sectors.
     While real-time MPEG streams is stored in CD-ROM mode 2 form 2
     sectors, which by have no L2 ECC, yield a ~14% greater user data
     area consisting of 2324 bytes(1)

     <http://www.dvdrhelp.com/vcd>

"Win32 ASPI"

     The ASPI interface specification was developed by Adaptec for
     sending commands to a SCSI host adapter (such as those controlling
     CD and DVD drives) and used on Window 9x/NT and later.  Emulation
     for ATAPI drives was added so that the same sets of commands worked
     those even though the drives might not be SCSI nor might there even
     be a SCSI controller attached.

     However in Windows NT/2K/XP, Microsoft provides their Win32 ioctl
     interface, and has take steps to make using ASPI more inaccessible
     (e.g.  requiring administrative access to use ASPI).

     See also *note MMC: MMC.

"Win32 ioctl driver"

     Ioctl (Input Output ConTroLs).  A Win32 function, implemented in
     all Microsoft Windows.  It is used for sending commands to devices
     using defined codes and structures.

"XA"

     *Note CD-ROM XA: XA.

   ---------- Footnotes ----------

   (1) actually raw mode 2 sectors have a 2336 byte user data area, but
parts of it are used for error codes and headers when using the mode 2
form 1 or form 2 configurations.


File: libcdio.info,  Node: GNU Free Documentation License,  Next: General Index,  Prev: Glossary,  Up: Top

Appendix C GNU Free Documentation License
*****************************************

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: libcdio.info,  Node: General Index,  Prev: GNU Free Documentation License,  Up: Top

General Index
*************

 [index ]
* Menu:

* ASPI:                                  Glossary.            (line  10)
* ASPI <1>:                              Glossary.            (line 492)
* BIN/CUE, CD Image Format:              CDRWIN BIN/CUE Format.
                                                              (line   6)
* Blu-ray Disc (BD):                     Glossary.            (line  39)
* CD:                                    Glossary.            (line  44)
* CD Text:                               CD Text.             (line   6)
* CD Text <1>:                           Glossary.            (line  92)
* CD XA:                                 Glossary.            (line 106)
* CD+G:                                  CD Text.             (line   6)
* CD+G <1>:                              Glossary.            (line  56)
* CD-DA:                                 Pre-gaps.            (line   6)
* CD-DA <1>:                             Glossary.            (line  48)
* CD-i:                                  Glossary.            (line  63)
* CD-i Bridge:                           Glossary.            (line  72)
* CD-ROM:                                Glossary.            (line  77)
* CDB (Command Descriptor Block):        SCSI mess.           (line  59)
* CDDB:                                  CDDB.                (line   6)
* Command Packet:                        Glossary.            (line 140)
* Defect management:                     Glossary.            (line 131)
* DVD:                                   Glossary.            (line 126)
* ECMA-119:                              Glossary.            (line 145)
* ECMA-167:                              Glossary.            (line 151)
* ECMA-168:                              Glossary.            (line 157)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* frames:                                Sectors.             (line   6)
* FSF:                                   Glossary.            (line 163)
* gaps:                                  Tracks.              (line   6)
* gaps <1>:                              Pre-gaps.            (line   6)
* GNU:                                   Glossary.            (line 167)
* Green Book:                            Green Book.          (line   6)
* Green Book <1>:                        White Book.          (line   6)
* ISO:                                   Glossary.            (line 177)
* ISO 13346:                             Glossary.            (line 181)
* ISO 13490:                             Glossary.            (line 187)
* ISO 9660:                              ISO 9660.            (line   6)
* ISO 9660 <1>:                          Glossary.            (line 193)
* Joliet extensions:                     Joliet Extensions.   (line   6)
* Joliet extensions <1>:                 Glossary.            (line 214)
* LBA:                                   Sectors.             (line   6)
* LBA <1>:                               Glossary.            (line 227)
* lead in:                               Pre-gaps.            (line   6)
* lead in <1>:                           Glossary.            (line 235)
* lead out:                              Tracks.              (line  19)
* lead out <1>:                          Pre-gaps.            (line   6)
* LSN:                                   Sectors.             (line   6)
* LSN <1>:                               Glossary.            (line 249)
* MCN:                                   Glossary.            (line 258)
* Media models and profiles:             Glossary.            (line 279)
* Mixed Mode CD:                         Glossary.            (line 338)
* MMC (Multimedia Commands):             Glossary.            (line 263)
* Mode 1:                                Mode 1.              (line   6)
* Mode 2:                                Mode 2.              (line   6)
* MSF:                                   Sectors.             (line   6)
* Multisession:                          Glossary.            (line 345)
* Nero NRG, CD-Image format:             NRG Format.          (line   6)
* Nero NRG, CD-Image format <1>:         Glossary.            (line 371)
* pre-gap:                               Pre-gaps.            (line   6)
* Q sub-channel:                         Pre-gaps.            (line   6)
* Red Book:                              Red Book.            (line   6)
* Rock Ridge extensions:                 Rock Ridge Extensions.
                                                              (line   6)
* Rock Ridge extensions <1>:             Glossary.            (line 377)
* SCSI:                                  Glossary.            (line 387)
* SCSI CDB:                              Glossary.            (line 411)
* SCSI Pass Through Interface.:          Glossary.            (line 416)
* sectors:                               Sectors.             (line   6)
* subchannel:                            Red Book.            (line  29)
* Super VCD (SVCD):                      Glossary.            (line 428)
* TOC (CD Table of Contents):            Glossary.            (line 443)
* track:                                 Tracks.              (line   6)
* track <1>:                             Glossary.            (line 454)
* UDF:                                   Glossary.            (line 465)
* Video CD (VCD):                        Glossary.            (line 473)
* XA:                                    Glossary.            (line 513)



Tag Table:
Node: Top813
Node: History2213
Node: Previous Work4259
Ref: Previous Work-Footnote-18416
Ref: Previous Work-Footnote-28542
Node: Purpose8812
Ref: Purpose-Footnote-113503
Node: CD Formats13695
Node: Red Book14489
Node: CD Text15964
Node: CDDB17933
Node: Yellow Book19311
Node: ISO 966019859
Node: ISO 9660 Level 120700
Node: ISO 9660 Level 221322
Node: ISO 9660 Level 321595
Node: Joliet Extensions22370
Node: Rock Ridge Extensions23482
Node: Mode 124423
Node: Mode 225297
Node: Green Book26312
Node: White Book27077
Node: CD Image Formats28014
Node: CDRDAO TOC Format29303
Node: CDRWIN BIN/CUE Format33003
Node: NRG Format34845
Node: CD Units35613
Node: Tracks35872
Node: Sectors37552
Ref: Sectors-Footnote-140555
Node: Pre-gaps40672
Node: How to use48255
Node: Include problem49466
Ref: Include problem-Footnote-152247
Node: Example 152388
Node: Example 256187
Node: Example 357753
Node: Example 464010
Node: Example 567109
Node: Example 669219
Node: Example 772070
Node: Example 876909
Node: All sample programs80802
Node: Utility Programs84066
Node: cd-drive84618
Node: cd-info84857
Node: cd-read85335
Node: iso-info85659
Node: iso-read85858
Node: CD-ROM Access and Drivers86032
Node: SCSI mess86557
Node: Access Modes90520
Node: Accessing Driver Parameters91702
Node: GNU/Linux92546
Node: Microsoft93227
Node: Solaris94139
Node: FreeBSD94606
Node: OS X95106
Node: Internal Program Organization95799
Node: File Organization96087
Node: Library Organization98055
Node: libcdio98507
Node: libcdio_cdda100125
Node: libcdio_paranoia100401
Node: libiso9660100756
Node: libudf101189
Node: Programming Conventions101400
Node: Coding Conventions101637
Node: Namespace Conventions101949
Node: ISO-9660 Character Sets104952
Node: ISO646 d-Characters105267
Node: ISO646 a-Characters105804
Node: Glossary106341
Ref: ASPI106618
Ref: XA110165
Ref: MMC116367
Ref: models-profiles116936
Ref: SCSI121798
Ref: Glossary-Footnote-1127007
Node: GNU Free Documentation License127184
Node: General Index149592

End Tag Table
